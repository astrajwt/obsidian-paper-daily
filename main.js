/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PaperDailyPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var PROVIDER_PRESETS = {
  deepseek: {
    label: "DeepSeek",
    provider: "openai_compatible",
    baseUrl: "https://api.deepseek.com/v1",
    models: ["deepseek-chat", "deepseek-reasoner"],
    keyPlaceholder: "sk-..."
  },
  openai: {
    label: "OpenAI",
    provider: "openai_compatible",
    baseUrl: "https://api.openai.com/v1",
    models: ["gpt-4o-mini", "gpt-4o", "gpt-4-turbo"],
    keyPlaceholder: "sk-..."
  },
  anthropic: {
    label: "Claude",
    provider: "anthropic",
    baseUrl: "",
    models: ["claude-3-5-haiku-latest", "claude-3-5-sonnet-latest", "claude-opus-4-5"],
    keyPlaceholder: "sk-ant-..."
  },
  glm: {
    label: "GLM / \u667A\u8C31",
    provider: "openai_compatible",
    baseUrl: "https://open.bigmodel.cn/api/paas/v4",
    models: ["glm-4-flash", "glm-4-air", "glm-4", "glm-z1-flash"],
    keyPlaceholder: "your-zhipu-api-key"
  },
  minimax: {
    label: "MiniMax",
    provider: "openai_compatible",
    baseUrl: "https://api.minimax.chat/v1",
    models: ["MiniMax-Text-01", "abab6.5s-chat", "abab5.5-chat"],
    keyPlaceholder: "your-minimax-api-key"
  },
  moonshot: {
    label: "Moonshot / Kimi",
    provider: "openai_compatible",
    baseUrl: "https://api.moonshot.cn/v1",
    models: ["moonshot-v1-128k", "moonshot-v1-32k", "moonshot-v1-8k"],
    keyPlaceholder: "sk-..."
  },
  qwen: {
    label: "Qwen / \u901A\u4E49",
    provider: "openai_compatible",
    baseUrl: "https://dashscope.aliyuncs.com/compatible-mode/v1",
    models: ["qwen-plus", "qwen-turbo", "qwen-max", "qwen-long"],
    keyPlaceholder: "sk-..."
  },
  custom: {
    label: "Custom",
    provider: "openai_compatible",
    baseUrl: "",
    models: [],
    keyPlaceholder: "your-api-key"
  }
};
function detectPreset(baseUrl) {
  for (const [key, preset] of Object.entries(PROVIDER_PRESETS)) {
    if (key === "custom")
      continue;
    if (preset.baseUrl && baseUrl.startsWith(preset.baseUrl))
      return key;
  }
  return baseUrl ? "custom" : "deepseek";
}
var DEFAULT_DAILY_PROMPT = `You are a senior AI/ML research analyst and critical peer reviewer. You combine deep engineering insight with academic rigor. Be direct and opinionated.

Today: {{date}}
Output language: {{language}}

---

## User's interest keywords (with weights, higher = more important):
{{interest_keywords}}

## Papers to analyze (pre-ranked, arXiv + HuggingFace combined):
{{papers_json}}

{{hf_data_section}}

{{fulltext_section}}

---

## Instructions

Generate the daily digest with the following sections:

### \u4ECA\u65E5\u8981\u70B9 / Key Takeaways
3\u20135 punchy bullet points. What actually moved the needle today vs what is incremental noise? Be direct.

### \u7CBE\u9009\u8BBA\u6587 / Curated Papers
For **each paper** in the papers list, output exactly this structure:

**[N]. {title}**
- \u2B50 \u4EF7\u503C\u8BC4\u7EA7: {\u2605\u2605\u2605\u2605\u2605 to \u2605\u2606\u2606\u2606\u2606}  ({one-phrase reason})
- \u5173\u952E\u8BCD: {interest hits}
- \u{1F917} HF \u70ED\u5EA6: {hfUpvotes} \u8D5E  \u2190 **only include this line if hfUpvotes > 0 for this paper; omit entirely otherwise**
- \u{1F4A1} \u6838\u5FC3\u8D21\u732E: one sentence \u2014 what exactly did they do / prove / build? Be specific with method names and key numbers.
- \u{1F52C} \u65B9\u6CD5\u6838\u5FC3: key technical novelty \u2014 principled or ad hoc? any theoretical guarantees or assumptions worth noting?
  > If a Deep Read note exists for this paper (see fulltext_section above), draw directly from it here and in \u5DE5\u7A0B\u542F\u793A / \u5C40\u9650\u6027. Prefer that analysis over the abstract.
- \u{1F4CA} \u5B9E\u9A8C\u4E25\u8C28\u6027: are baselines fair and up-to-date? ablations sufficient? any obvious cherry-picking or missing controls?
- \u{1F527} \u5DE5\u7A0B\u542F\u793A: what can a practitioner adopt? Be concrete \u2014 "use X to achieve Y", not "this is interesting".
- \u26A0\uFE0F \u5C40\u9650\u6027 & \u53EF\u590D\u73B0\u6027: scope limitations + code availability + compute requirements. Can a grad student replicate this?
- \u{1F4DA} \u5EFA\u8BAE: {Skip | Read abstract | Skim methods | Read in full | Implement & test}
- \u{1F517} links from the paper data (arXiv / HF / PDF as available)

Value rating guide \u2014 be calibrated, not generous:
\u2605\u2605\u2605\u2605\u2605  Breakthrough: likely to shift practice or become a citation anchor
\u2605\u2605\u2605\u2605\u2606  Strong: clear improvement, solid evaluation, worth reading in full
\u2605\u2605\u2605\u2606\u2606  Solid: incremental but honest; good for domain awareness
\u2605\u2605\u2606\u2606\u2606  Weak: narrow scope, questionable baselines, or limited novelty
\u2605\u2606\u2606\u2606\u2606  Skip: below standard, off-topic, or superseded

{{hf_signal_section}}

### \u4ECA\u65E5\u6279\u6B21\u8D28\u91CF & \u7ED3\u8BED / Batch Quality & Closing
2\u20133 sentences: Is today a high-signal or low-signal day? What's the overall quality distribution? The single most important thing to keep an eye on from today's batch.

---
Rules:
- Do NOT hedge every sentence. State your assessment directly.
- Call out benchmark overfitting, p-hacking, insufficient baselines, or vague claims explicitly.
- If hfUpvotes is high but interest keyword relevance is low, note the discrepancy.
- If a paper seems overhyped relative to its technical content, say so.
- Keep engineering perspective front and center.
- \u5DE5\u7A0B\u542F\u793A must be actionable \u2014 not "this is interesting" but "you can use X to achieve Y in your system".
- Recommendations must be specific \u2014 no "interesting direction" hedging.
- If fulltext_section is non-empty, you MUST use those deep-read notes to enrich the analysis of the corresponding papers. Do not ignore them.
- HuggingFace papers in papers_json must receive the same full analysis treatment as arXiv papers.`;
var DEFAULT_SCORING_PROMPT = `Score each paper 1\u201310 for quality and relevance to the user's interests.

User's interest keywords (higher weight = more important): {{interest_keywords}}

Scoring criteria:
- Alignment with interest keywords and their weights
- Technical novelty and depth
- Practical engineering value
- Quality of evaluation / experiments

Return ONLY a valid JSON array, no explanation, no markdown fence:
[{"id":"arxiv:...","score":8,"reason":"one short phrase","summary":"1\u20132 sentence plain-language summary"},...]

Papers:
{{papers_json}}`;
var DEFAULT_DEEP_READ_PROMPT = `You are a senior AI/ML research analyst. Write a self-contained deep-read note for this paper \u2014 it will be saved as a standalone Markdown reference document.

**Paper:**
Title: {{title}}
Authors: {{authors}}
Published: {{published}}
arXiv: {{arxiv_url}}
Keyword hits: {{interest_hits}}

**Abstract:**
{{abstract}}

**Full paper** (read directly if the URL is accessible): {{fulltext}}

---

Write the note with the following Markdown sections. Be direct, opinionated, and technically precise. No filler phrases.

## TL;DR
One sentence: what they built/proved + the single most important result number.

## \u6838\u5FC3\u8D21\u732E / Core Contribution
2\u20133 sentences. What exactly is new? Method name, dataset, metric, key numbers.

## \u65B9\u6CD5 / Method
3\u20135 bullet points. Key technical decisions and why they matter. What distinguishes this from prior work at the mechanism level?

## \u5B9E\u9A8C\u7ED3\u679C / Results
- Which benchmarks / tasks
- Headline numbers vs strongest baseline (exact figures)
- Key ablation finding (if any)
- What is suspiciously missing or underreported?

## \u5DE5\u7A0B\u542F\u793A / Engineering Takeaway
1\u20132 sentences. What can a practitioner directly adopt? "Use X to achieve Y" \u2014 not "this is interesting".

## \u5C40\u9650\u6027 / Limitations
1\u20132 sentences. Scope, compute requirements, reproducibility, failure modes in production.

## \u76F8\u5173\u5DE5\u4F5C / Related Work
2\u20133 papers this most directly builds on or competes with. One line each: title + why it's relevant.

---
Output language: {{language}}
Aim for 400\u2013600 words total. Do not copy the abstract verbatim \u2014 synthesize.`;
var DEFAULT_PROMPT_LIBRARY = [
  { id: "builtin_engineering", name: "\u6BCF\u65E5trending", type: "daily", prompt: DEFAULT_DAILY_PROMPT, builtin: true },
  { id: "builtin_scoring", name: "\u6279\u91CF\u8BC4\u5206", type: "scoring", prompt: DEFAULT_SCORING_PROMPT, builtin: true },
  { id: "builtin_deepread", name: "\u5168\u6587\u7CBE\u8BFB", type: "deepread", prompt: DEFAULT_DEEP_READ_PROMPT, builtin: true }
];
var DEFAULT_SETTINGS = {
  categories: ["cs.AI", "cs.LG", "cs.CL"],
  // Matching is case-insensitive (keywords are lowercased before comparison)
  interestKeywords: [
    { keyword: "rlhf", weight: 5 },
    { keyword: "agent", weight: 5 },
    { keyword: "kv cache", weight: 4 },
    { keyword: "speculative decoding", weight: 4 },
    { keyword: "moe", weight: 4 },
    { keyword: "inference serving", weight: 4 },
    { keyword: "reasoning", weight: 3 },
    { keyword: "post-training", weight: 3 },
    { keyword: "distillation", weight: 3 },
    { keyword: "quantization", weight: 3 }
  ],
  fetchMode: "all",
  dedup: true,
  timeWindowHours: 72,
  llm: {
    provider: "openai_compatible",
    baseUrl: "https://api.openai.com/v1",
    apiKey: "",
    model: "gpt-4o-mini",
    temperature: 0.3,
    maxTokens: 4096,
    dailyPromptTemplate: DEFAULT_DAILY_PROMPT
  },
  rootFolder: "PaperDaily",
  language: "zh",
  includeAbstract: true,
  includePdfLink: true,
  schedule: {
    dailyTime: "08:30"
  },
  backfillMaxDays: 30,
  hfSource: {
    enabled: true,
    lookbackDays: 3,
    dedup: false
  },
  rssSource: {
    enabled: false,
    feeds: []
  },
  paperDownload: {
    savePdf: true
  },
  deepRead: {
    enabled: false,
    topN: 5,
    deepReadMaxTokens: 2048,
    outputFolder: "PaperDaily/deep-read",
    tags: ["paper", "deep-read"]
    // deepReadPromptTemplate intentionally omitted â†’ pipeline falls back to DEFAULT_DEEP_READ_PROMPT
  },
  promptLibrary: DEFAULT_PROMPT_LIBRARY.map((t) => ({ ...t })),
  activePromptId: "builtin_engineering",
  activeScorePromptId: "builtin_scoring",
  activeDeepReadPromptId: "builtin_deepread"
};
var PaperDailySettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    var _a2, _b;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Paper Daily \u8BBE\u7F6E / Settings" });
    containerEl.createEl("h2", { text: "arXiv \u8BBA\u6587\u6293\u53D6 / Fetch" });
    new import_obsidian.Setting(containerEl).setName("\u5206\u7C7B / Categories").setDesc("arXiv \u5206\u7C7B\uFF0C\u9017\u53F7\u5206\u9694 | Comma-separated arXiv categories (e.g. cs.AI,cs.LG,cs.CL)").addText((text) => text.setPlaceholder("cs.AI,cs.LG,cs.CL").setValue(this.plugin.settings.categories.join(",")).onChange(async (value) => {
      this.plugin.settings.categories = value.split(",").map((s) => s.trim()).filter(Boolean);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u62C9\u53D6\u65B9\u5F0F / Fetch Mode").setDesc(
      "\u5168\u91CF\u62C9\u53D6\uFF1A\u6293\u53D6\u5206\u7C7B\u4E0B\u6240\u6709\u8BBA\u6587\uFF08\u7531 LLM \u6253\u5206\u540E\u6392\u5E8F\u5C55\u793A\uFF09\n\u4EC5\u5174\u8DA3\u5173\u952E\u8BCD\uFF1A\u53EA\u4FDD\u7559\u547D\u4E2D\u81F3\u5C11\u4E00\u4E2A\u5174\u8DA3\u5173\u952E\u8BCD\u7684\u8BBA\u6587\uFF0C\u9002\u5408\u5173\u952E\u8BCD\u8986\u76D6\u5168\u9762\u65F6\u4F7F\u7528\u3002\n\nFetch all: retrieve all papers in the selected categories and let LLM scoring determine relevance.\nInterest only: keep only papers matching at least one interest keyword \u2014 best when your keyword list is comprehensive."
    ).addDropdown((drop) => {
      var _a3;
      return drop.addOption("all", "\u5168\u91CF\u62C9\u53D6 / Fetch All").addOption("interest_only", "\u4EC5\u5174\u8DA3\u5173\u952E\u8BCD / Interest Only").setValue((_a3 = this.plugin.settings.fetchMode) != null ? _a3 : "all").onChange(async (value) => {
        this.plugin.settings.fetchMode = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u4FDD\u5B58 PDF / Save PDF").setDesc("\u4E0B\u8F7D\u8BBA\u6587 PDF \u5E76\u5B58\u5165 Vault\uFF08papers/pdf/\u65E5\u671F/\uFF09\uFF0C\u5DF2\u4E0B\u8F7D\u7684\u6587\u4EF6\u81EA\u52A8\u8DF3\u8FC7 | Download paper PDFs into the vault (papers/pdf/date/). Already-downloaded files are skipped.").addToggle((toggle) => {
      var _a3, _b2;
      return toggle.setValue((_b2 = (_a3 = this.plugin.settings.paperDownload) == null ? void 0 : _a3.savePdf) != null ? _b2 : false).onChange(async (value) => {
        this.plugin.settings.paperDownload = { ...this.plugin.settings.paperDownload, savePdf: value };
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u53BB\u91CD / Dedup").setDesc("\u8DF3\u8FC7\u5DF2\u5728\u5F80\u671F\u65E5\u62A5\u4E2D\u51FA\u73B0\u8FC7\u7684\u8BBA\u6587\uFF0C\u907F\u514D\u91CD\u590D\u5C55\u793A\u3002\u5173\u95ED\u540E\u6BCF\u6B21\u8FD0\u884C\u90FD\u4F1A\u91CD\u65B0\u5904\u7406\u5168\u90E8\u62C9\u53D6\u7ED3\u679C | Skip papers already shown in a previous daily report. Disable to reprocess all fetched papers every run.").addToggle((toggle) => {
      var _a3;
      return toggle.setValue((_a3 = this.plugin.settings.dedup) != null ? _a3 : true).onChange(async (value) => {
        this.plugin.settings.dedup = value;
        await this.plugin.saveSettings();
      });
    }).addButton((btn) => btn.setButtonText("\u6E05\u7A7A\u7F13\u5B58 / Clear").setWarning().onClick(async () => {
      await this.plugin.clearDedup();
      new import_obsidian.Notice("\u53BB\u91CD\u7F13\u5B58\u5DF2\u6E05\u7A7A / Dedup cache cleared.");
    }));
    new import_obsidian.Setting(containerEl).setName("HuggingFace \u8BBA\u6587\u6E90 / HuggingFace Source").setDesc("\u5F00\u542F\u540E\u6293\u53D6 huggingface.co/papers \u6BCF\u65E5\u7CBE\u9009\uFF0C\u4E0E arXiv \u7ED3\u679C\u5408\u5E76\u6392\u540D | Fetch HuggingFace daily papers and merge with arXiv results").addToggle((toggle) => {
      var _a3;
      return toggle.setValue(((_a3 = this.plugin.settings.hfSource) == null ? void 0 : _a3.enabled) !== false).onChange(async (value) => {
        this.plugin.settings.hfSource = { ...this.plugin.settings.hfSource, enabled: value };
        await this.plugin.saveSettings();
        this.display();
      });
    });
    if (((_a2 = this.plugin.settings.hfSource) == null ? void 0 : _a2.enabled) !== false) {
      new import_obsidian.Setting(containerEl).setName("HuggingFace \u56DE\u6EAF\u5929\u6570 / HuggingFace Lookback Days").setDesc("huggingface.co/papers \u65E0\u5F53\u65E5\u6570\u636E\u65F6\uFF08\u5982\u5468\u672B\uFF09\uFF0C\u5F80\u524D\u67E5\u627E\u6700\u8FD1 N \u5929\u7684\u7CBE\u9009 | If today has no HuggingFace papers (e.g. weekend), look back up to N days").addSlider((slider) => {
        var _a3, _b2;
        return slider.setLimits(0, 7, 1).setValue((_b2 = (_a3 = this.plugin.settings.hfSource) == null ? void 0 : _a3.lookbackDays) != null ? _b2 : 3).setDynamicTooltip().onChange(async (value) => {
          this.plugin.settings.hfSource = { ...this.plugin.settings.hfSource, lookbackDays: value };
          await this.plugin.saveSettings();
        });
      });
    }
    new import_obsidian.Setting(containerEl).setName("\u65F6\u95F4\u7A97\u53E3\uFF08\u5C0F\u65F6\uFF09/ Time Window (hours)").setDesc("\u6293\u53D6\u8FC7\u53BB N \u5C0F\u65F6\u5185\u53D1\u5E03\u6216\u66F4\u65B0\u7684\u8BBA\u6587\uFF0C\u9ED8\u8BA4 72 \u5C0F\u65F6\u8986\u76D6\u5468\u672B | Fetch papers published/updated within the past N hours. Default 72 covers weekends.").addSlider((slider) => {
      var _a3;
      return slider.setLimits(24, 168, 24).setValue((_a3 = this.plugin.settings.timeWindowHours) != null ? _a3 : 72).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.timeWindowHours = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("RSS \u8BA2\u9605\u6E90 / RSS Sources").setDesc("\u{1F6A7} Coming Soon \u2014 \u81EA\u5B9A\u4E49 RSS/Atom \u8BA2\u9605\u6E90\u5C06\u5728\u540E\u7EED\u7248\u672C\u652F\u6301 | Custom RSS/Atom feed ingestion is planned for a future release.");
    containerEl.createEl("h2", { text: "\u5174\u8DA3\u5173\u952E\u8BCD / Interest Keywords" });
    containerEl.createEl("p", {
      text: "\u7528\u4E8E\u8BBA\u6587\u6253\u5206\u4E0E\u9AD8\u4EAE\u663E\u793A\uFF0C\u6743\u91CD\u8D8A\u9AD8\u6392\u540D\u8D8A\u9760\u524D\u3002\u5339\u914D\u4E0D\u533A\u5206\u5927\u5C0F\u5199\u3002",
      cls: "setting-item-description"
    });
    const kwListEl = containerEl.createDiv();
    const renderKwList = () => {
      kwListEl.empty();
      const kws = this.plugin.settings.interestKeywords;
      kws.forEach((kw, i) => {
        new import_obsidian.Setting(kwListEl).addText((text) => text.setPlaceholder("keyword").setValue(kw.keyword).onChange(async (val) => {
          kws[i].keyword = val.trim();
          await this.plugin.saveSettings();
        })).addSlider((slider) => slider.setLimits(1, 5, 1).setValue(kw.weight).setDynamicTooltip().onChange(async (val) => {
          kws[i].weight = val;
          await this.plugin.saveSettings();
        })).addExtraButton((btn) => btn.setIcon("trash").setTooltip("Remove").onClick(async () => {
          kws.splice(i, 1);
          await this.plugin.saveSettings();
          renderKwList();
        }));
      });
    };
    renderKwList();
    new import_obsidian.Setting(containerEl).addButton((btn) => btn.setButtonText("+ \u6DFB\u52A0\u5173\u952E\u8BCD").setCta().onClick(async () => {
      this.plugin.settings.interestKeywords.push({ keyword: "", weight: 3 });
      await this.plugin.saveSettings();
      renderKwList();
    }));
    containerEl.createEl("h2", { text: "Prompt \u6A21\u677F\u5E93 / Prompt Library" });
    {
      const TYPE_LABELS = { daily: "\u65E5\u62A5", scoring: "\u8BC4\u5206", deepread: "\u7CBE\u8BFB" };
      const TYPE_COLORS = { daily: "#4a90d9", scoring: "#5cb85c", deepread: "#9b59b6" };
      const desc = containerEl.createEl("div", { cls: "setting-item-description" });
      desc.createEl("p", { text: "\u70B9\u51FB Tab \u53EF\u5207\u6362\u6A21\u677F\u5E76\u5C06\u5176\u8BBE\u4E3A\u5BF9\u5E94\u529F\u80FD\u7684\u6FC0\u6D3B\u6A21\u677F\u3002" });
      const table = desc.createEl("table");
      table.style.fontSize = "11px";
      table.style.borderCollapse = "collapse";
      table.style.width = "100%";
      const rows = [
        ["[\u65E5\u62A5] {{date}}", "\u5F53\u65E5\u65E5\u671F YYYY-MM-DD"],
        ["[\u65E5\u62A5] {{papers_json}}", "\u6392\u540D\u540E\u8BBA\u6587\u5217\u8868 JSON\uFF08\u6700\u591A 20 \u7BC7\uFF0C\u542B arXiv + HF\uFF09"],
        ["[\u65E5\u62A5] {{hf_data_section}}", "HF \u6570\u636E\u5757\uFF08HF \u5F00\u542F\u65F6\u542B\u6807\u9898+JSON\uFF0C\u5173\u95ED\u65F6\u4E3A\u7A7A\uFF09"],
        ["[\u65E5\u62A5] {{hf_signal_section}}", "HF \u793E\u533A\u4FE1\u53F7\u6307\u4EE4\u5757\uFF08HF \u5F00\u542F\u65F6\u6CE8\u5165\uFF0C\u5173\u95ED\u65F6\u4E3A\u7A7A\uFF09"],
        ["[\u65E5\u62A5] {{fulltext_section}}", "Deep Read \u7CBE\u8BFB\u7ED3\u679C\uFF08Markdown\uFF09"],
        ["[\u65E5\u62A5] {{interest_keywords}}", "\u5174\u8DA3\u5173\u952E\u8BCD\u53CA\u6743\u91CD"],
        ["[\u65E5\u62A5] {{language}}", "Chinese (\u4E2D\u6587) \u6216 English"],
        ["[\u8BC4\u5206] {{interest_keywords}}", "\u5174\u8DA3\u5173\u952E\u8BCD\u53CA\u6743\u91CD"],
        ["[\u8BC4\u5206] {{papers_json}}", "\u672C\u6279\u8BBA\u6587 JSON\uFF08\u542B id/title/abstract/interestHits/hfUpvotes\uFF09"],
        ["[\u7CBE\u8BFB] {{title}} {{authors}}", "\u8BBA\u6587\u6807\u9898 / \u524D 5 \u4F4D\u4F5C\u8005"],
        ["[\u7CBE\u8BFB] {{published}} {{arxiv_url}}", "\u53D1\u5E03\u65E5\u671F / arXiv \u94FE\u63A5"],
        ["[\u7CBE\u8BFB] {{interest_hits}}", "\u547D\u4E2D\u7684\u5174\u8DA3\u5173\u952E\u8BCD"],
        ["[\u7CBE\u8BFB] {{abstract}}", "\u6458\u8981\u5168\u6587"],
        ["[\u7CBE\u8BFB] {{fulltext}}", "arxiv.org/html URL\uFF08\u8BA9\u6A21\u578B\u76F4\u63A5\u8BFB\uFF09"],
        ["[\u7CBE\u8BFB] {{language}}", "Chinese (\u4E2D\u6587) \u6216 English"]
      ];
      for (const [ph, explain] of rows) {
        const tr = table.createEl("tr");
        const td1 = tr.createEl("td");
        td1.style.padding = "2px 8px 2px 0";
        td1.style.whiteSpace = "nowrap";
        td1.style.fontFamily = "monospace";
        td1.style.color = "var(--text-accent)";
        td1.setText(ph);
        const td2 = tr.createEl("td");
        td2.style.padding = "2px 0";
        td2.style.color = "var(--text-muted)";
        td2.setText(explain);
      }
      desc.style.marginBottom = "10px";
      if (!this.plugin.settings.promptLibrary || this.plugin.settings.promptLibrary.length === 0) {
        this.plugin.settings.promptLibrary = DEFAULT_PROMPT_LIBRARY.map((t) => ({ ...t }));
        this.plugin.settings.activePromptId = "builtin_engineering";
        this.plugin.settings.activeScorePromptId = "builtin_scoring";
        this.plugin.settings.activeDeepReadPromptId = "builtin_deepread";
      }
      const lib = this.plugin.settings.promptLibrary;
      for (const def of DEFAULT_PROMPT_LIBRARY) {
        if (!lib.find((t) => t.id === def.id))
          lib.push({ ...def });
      }
      for (const def of DEFAULT_PROMPT_LIBRARY) {
        const existing = lib.find((t) => t.id === def.id);
        if (existing && !existing.type)
          existing.type = def.type;
      }
      if (!this.plugin.settings.activePromptId)
        this.plugin.settings.activePromptId = "builtin_engineering";
      if (!this.plugin.settings.activeScorePromptId)
        this.plugin.settings.activeScorePromptId = "builtin_scoring";
      if (!this.plugin.settings.activeDeepReadPromptId)
        this.plugin.settings.activeDeepReadPromptId = "builtin_deepread";
      const getActiveIdForType = (type) => {
        if (type === "scoring")
          return this.plugin.settings.activeScorePromptId;
        if (type === "deepread")
          return this.plugin.settings.activeDeepReadPromptId;
        return this.plugin.settings.activePromptId;
      };
      const setActiveIdForType = async (type, id) => {
        if (type === "scoring")
          this.plugin.settings.activeScorePromptId = id;
        else if (type === "deepread")
          this.plugin.settings.activeDeepReadPromptId = id;
        else
          this.plugin.settings.activePromptId = id;
        await this.plugin.saveSettings();
      };
      let selectedId = this.plugin.settings.activePromptId;
      const tabBar = containerEl.createDiv();
      tabBar.style.cssText = "display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px;align-items:center;";
      const promptTA = containerEl.createEl("textarea");
      promptTA.style.cssText = "width:100%;height:300px;font-family:monospace;font-size:11px;padding:8px;resize:vertical;box-sizing:border-box;";
      const actionsRow = containerEl.createDiv();
      actionsRow.style.cssText = "display:flex;gap:8px;margin-top:8px;flex-wrap:wrap;align-items:center;";
      const renderTabs = () => {
        var _a3, _b2, _c;
        tabBar.empty();
        for (const tpl of lib) {
          const tplType = (_a3 = tpl.type) != null ? _a3 : "daily";
          const activeIdForType = getActiveIdForType(tplType);
          const isSelected = tpl.id === selectedId;
          const isActiveForType = tpl.id === activeIdForType;
          const typeColor = (_b2 = TYPE_COLORS[tplType]) != null ? _b2 : "#888";
          const typeLabel = (_c = TYPE_LABELS[tplType]) != null ? _c : tplType;
          const btn = tabBar.createEl("button");
          const badge = btn.createEl("span", { text: typeLabel });
          badge.style.cssText = `display:inline-block;font-size:0.75em;padding:1px 5px;border-radius:3px;margin-right:5px;background:${typeColor};color:#fff;font-weight:600;vertical-align:middle;`;
          btn.appendText(tpl.name);
          if (isActiveForType) {
            const dot = btn.createEl("span", { text: " \u2713" });
            dot.style.cssText = `color:${typeColor};font-weight:700;`;
          }
          const accent = "var(--interactive-accent)";
          const border = "var(--background-modifier-border)";
          btn.style.cssText = [
            "padding:5px 12px",
            "border-radius:5px",
            "cursor:pointer",
            "font-size:0.85em",
            `border:2px solid ${isSelected ? accent : border}`,
            `background:${isSelected ? accent : "var(--background-secondary)"}`,
            `color:${isSelected ? "var(--text-on-accent)" : "var(--text-normal)"}`,
            "font-weight:" + (isSelected ? "600" : "400"),
            "transition:all 0.1s"
          ].join(";");
          btn.onclick = async () => {
            selectedId = tpl.id;
            await setActiveIdForType(tplType, tpl.id);
            promptTA.value = tpl.prompt;
            renderTabs();
            renderActions();
          };
        }
        const typeSelect = tabBar.createEl("select");
        typeSelect.style.cssText = "padding:4px 8px;border-radius:5px;font-size:0.85em;border:1px solid var(--background-modifier-border);background:var(--background-secondary);color:var(--text-normal);cursor:pointer;";
        [["daily", "\u65E5\u62A5"], ["scoring", "\u8BC4\u5206"], ["deepread", "\u7CBE\u8BFB"]].forEach(([val, label]) => {
          const o = typeSelect.createEl("option", { text: label });
          o.value = val;
        });
        const addBtn = tabBar.createEl("button", { text: "\uFF0B \u65B0\u5EFA" });
        addBtn.style.cssText = "padding:5px 12px;border-radius:5px;cursor:pointer;font-size:0.85em;border:2px dashed var(--background-modifier-border);background:transparent;color:var(--text-muted);";
        addBtn.onclick = async () => {
          const newType = typeSelect.value;
          const defaultPrompt = newType === "scoring" ? DEFAULT_SCORING_PROMPT : newType === "deepread" ? DEFAULT_DEEP_READ_PROMPT : DEFAULT_DAILY_PROMPT;
          const newTpl = {
            id: `custom_${Date.now()}`,
            name: `\u81EA\u5B9A\u4E49 ${lib.filter((t) => !t.builtin).length + 1}`,
            type: newType,
            prompt: defaultPrompt
          };
          lib.push(newTpl);
          selectedId = newTpl.id;
          await setActiveIdForType(newType, newTpl.id);
          await this.plugin.saveSettings();
          promptTA.value = newTpl.prompt;
          renderTabs();
          renderActions();
        };
      };
      const renderActions = () => {
        actionsRow.empty();
        const tpl = lib.find((t) => t.id === selectedId);
        if (!tpl)
          return;
        const saveBtn = actionsRow.createEl("button", { text: "\u4FDD\u5B58 / Save" });
        saveBtn.style.cssText = "padding:4px 16px;border-radius:4px;cursor:pointer;font-size:0.85em;background:var(--interactive-accent);color:var(--text-on-accent);border:none;font-weight:600;";
        saveBtn.onclick = async () => {
          tpl.prompt = promptTA.value;
          await this.plugin.saveSettings();
          new import_obsidian.Notice(`\u6A21\u677F\u5DF2\u4FDD\u5B58\uFF1A${tpl.name}`);
        };
        const renameBtn = actionsRow.createEl("button", { text: "\u91CD\u547D\u540D / Rename" });
        renameBtn.style.cssText = "padding:4px 14px;border-radius:4px;cursor:pointer;font-size:0.85em;background:var(--background-secondary);border:1px solid var(--background-modifier-border);color:var(--text-normal);";
        renameBtn.onclick = async () => {
          const newName = prompt("\u65B0\u540D\u79F0 / New name:", tpl.name);
          if (newName == null ? void 0 : newName.trim()) {
            tpl.name = newName.trim();
            await this.plugin.saveSettings();
            renderTabs();
          }
        };
        if (tpl.builtin) {
          const resetBtn = actionsRow.createEl("button", { text: "\u91CD\u7F6E\u9ED8\u8BA4 / Reset" });
          resetBtn.style.cssText = "padding:4px 14px;border-radius:4px;cursor:pointer;font-size:0.85em;background:var(--background-secondary);border:1px solid var(--background-modifier-border);color:var(--text-muted);";
          resetBtn.onclick = async () => {
            const def = DEFAULT_PROMPT_LIBRARY.find((d) => d.id === tpl.id);
            if (def) {
              tpl.prompt = def.prompt;
              promptTA.value = tpl.prompt;
              await this.plugin.saveSettings();
              new import_obsidian.Notice("\u5DF2\u91CD\u7F6E\u4E3A\u9ED8\u8BA4 / Reset to default.");
            }
          };
        }
        if (!tpl.builtin && lib.length > 1) {
          const delBtn = actionsRow.createEl("button", { text: "\u5220\u9664 / Delete" });
          delBtn.style.cssText = "padding:4px 14px;border-radius:4px;cursor:pointer;font-size:0.85em;background:var(--background-secondary);border:1px solid var(--text-error,#cc4444);color:var(--text-error,#cc4444);";
          delBtn.onclick = async () => {
            var _a3;
            const idx = lib.findIndex((t) => t.id === selectedId);
            lib.splice(idx, 1);
            selectedId = lib[Math.max(0, idx - 1)].id;
            const prevTpl = lib.find((t) => t.id === selectedId);
            await setActiveIdForType((_a3 = prevTpl.type) != null ? _a3 : "daily", selectedId);
            promptTA.value = prevTpl.prompt;
            await this.plugin.saveSettings();
            renderTabs();
            renderActions();
          };
        }
      };
      const initTpl = (_b = lib.find((t) => t.id === selectedId)) != null ? _b : lib[0];
      promptTA.value = initTpl.prompt;
      renderTabs();
      renderActions();
    }
    containerEl.createEl("h2", { text: "\u5168\u6587\u7CBE\u8BFB / Deep Read" });
    const drSubContainer = containerEl.createDiv();
    const refreshDrSub = () => {
      var _a3;
      drSubContainer.style.display = ((_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.enabled) ? "" : "none";
    };
    new import_obsidian.Setting(containerEl).setName("\u5F00\u542F\u7CBE\u8BFB / Enable Deep Read").setDesc("\u6293\u53D6\u6392\u540D\u6700\u9AD8\u7684 N \u7BC7\u8BBA\u6587\u7684\u5168\u6587\uFF08arxiv.org/html\uFF09\uFF0C\u6CE8\u5165 LLM prompt\uFF0C\u8BA9\u6A21\u578B\u505A\u66F4\u6DF1\u5EA6\u7684\u9010\u7BC7\u5206\u6790 | Fetch full paper text and inject into the digest prompt for richer per-paper analysis").addToggle((toggle) => {
      var _a3, _b2;
      return toggle.setValue((_b2 = (_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.enabled) != null ? _b2 : false).onChange(async (value) => {
        this.plugin.settings.deepRead = { ...this.plugin.settings.deepRead, enabled: value };
        await this.plugin.saveSettings();
        refreshDrSub();
      });
    });
    new import_obsidian.Setting(drSubContainer).setName("\u7CBE\u8BFB\u7BC7\u6570 / Papers to fetch").setDesc("\u6BCF\u65E5\u6293\u53D6\u5168\u6587\u7684\u6700\u9AD8\u5206\u8BBA\u6587\u7BC7\u6570\uFF08\u5EFA\u8BAE 3\u20135\uFF0C\u8D8A\u591A prompt \u8D8A\u957F\uFF09| Number of top papers to fetch full text for").addSlider((slider) => {
      var _a3, _b2;
      return slider.setLimits(1, 10, 1).setValue((_b2 = (_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.topN) != null ? _b2 : 5).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.deepRead = { ...this.plugin.settings.deepRead, topN: value };
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(drSubContainer).setName("\u6BCF\u7BC7\u5206\u6790 Token \u4E0A\u9650 / Max tokens per paper").setDesc("Deep Read \u6BCF\u7BC7\u8BBA\u6587 LLM \u8C03\u7528\u7684\u8F93\u51FA token \u4E0A\u9650\uFF08\u9ED8\u8BA4 1024\uFF0C\u5EFA\u8BAE 512\u20132048\uFF09").addSlider((slider) => {
      var _a3, _b2;
      return slider.setLimits(256, 4096, 128).setValue((_b2 = (_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.deepReadMaxTokens) != null ? _b2 : 1024).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.deepRead = {
          ...this.plugin.settings.deepRead,
          deepReadMaxTokens: value
        };
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(drSubContainer).setName("\u8F93\u51FA\u76EE\u5F55 / Output Folder").setDesc("\u7CBE\u8BFB\u7B14\u8BB0\u4FDD\u5B58\u76EE\u5F55\uFF08Vault \u5185\u8DEF\u5F84\uFF09| Vault folder path for per-paper deep-read notes").addText((text) => {
      var _a3, _b2;
      return text.setPlaceholder("PaperDaily/deep-read").setValue((_b2 = (_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.outputFolder) != null ? _b2 : "PaperDaily/deep-read").onChange(async (value) => {
        this.plugin.settings.deepRead = {
          ...this.plugin.settings.deepRead,
          outputFolder: value.trim() || "PaperDaily/deep-read"
        };
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(drSubContainer).setName("\u6807\u7B7E / Tags").setDesc("\u9017\u53F7\u5206\u9694\uFF0C\u5199\u5165\u6BCF\u7BC7\u7CBE\u8BFB\u7B14\u8BB0\u7684 frontmatter tags | Comma-separated tags added to each paper note's frontmatter").addText((text) => {
      var _a3, _b2;
      return text.setPlaceholder("paper, deep-read").setValue(((_b2 = (_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.tags) != null ? _b2 : ["paper", "deep-read"]).join(", ")).onChange(async (value) => {
        const tags = value.split(",").map((s) => s.trim()).filter(Boolean);
        this.plugin.settings.deepRead = {
          ...this.plugin.settings.deepRead,
          tags
        };
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(drSubContainer).setName("\u6587\u4EF6\u540D\u6A21\u677F / File Name Template").setDesc("\u7CBE\u8BFB\u7B14\u8BB0\u7684\u6587\u4EF6\u540D\uFF08\u4E0D\u542B .md\uFF09\u3002\u53EF\u7528\u53D8\u91CF\uFF1A{{title}} {{arxivId}} {{date}} {{model}} {{year}} {{month}} {{day}} | File name (without .md). Variables: {{title}} {{arxivId}} {{date}} {{model}} {{year}} {{month}} {{day}}").addText((text) => {
      var _a3, _b2;
      return text.setPlaceholder("{{title}}-deep-read-{{model}}").setValue((_b2 = (_a3 = this.plugin.settings.deepRead) == null ? void 0 : _a3.fileNameTemplate) != null ? _b2 : "").onChange(async (value) => {
        this.plugin.settings.deepRead = {
          ...this.plugin.settings.deepRead,
          fileNameTemplate: value.trim()
        };
        await this.plugin.saveSettings();
      });
    });
    refreshDrSub();
    containerEl.createEl("h2", { text: "\u6A21\u578B\u914D\u7F6E / LLM Provider" });
    const presetWrap = containerEl.createDiv({ cls: "paper-daily-preset-wrap" });
    presetWrap.style.display = "flex";
    presetWrap.style.flexWrap = "wrap";
    presetWrap.style.gap = "6px";
    presetWrap.style.marginBottom = "16px";
    let activePreset = detectPreset(this.plugin.settings.llm.baseUrl);
    let baseUrlInput;
    let modelSelect;
    let customModelInput;
    let modelCustomRow;
    let apiKeyInput;
    const renderModelOptions = (presetKey) => {
      if (!modelSelect)
        return;
      const preset = PROVIDER_PRESETS[presetKey];
      modelSelect.empty();
      for (const m of preset.models) {
        const opt = modelSelect.createEl("option", { text: m, value: m });
        if (m === this.plugin.settings.llm.model)
          opt.selected = true;
      }
      const customOpt = modelSelect.createEl("option", { text: "Other (custom)...", value: "__custom__" });
      if (!preset.models.includes(this.plugin.settings.llm.model)) {
        customOpt.selected = true;
        if (modelCustomRow)
          modelCustomRow.style.display = "";
        if (customModelInput)
          customModelInput.value = this.plugin.settings.llm.model;
      } else {
        if (modelCustomRow)
          modelCustomRow.style.display = "none";
      }
    };
    const applyPreset = async (presetKey) => {
      activePreset = presetKey;
      const preset = PROVIDER_PRESETS[presetKey];
      this.plugin.settings.llm.provider = preset.provider;
      if (preset.baseUrl) {
        this.plugin.settings.llm.baseUrl = preset.baseUrl;
        if (baseUrlInput)
          baseUrlInput.value = preset.baseUrl;
      }
      if (apiKeyInput)
        apiKeyInput.placeholder = preset.keyPlaceholder;
      renderModelOptions(presetKey);
      if (preset.models.length > 0 && !preset.models.includes(this.plugin.settings.llm.model)) {
        this.plugin.settings.llm.model = preset.models[0];
        if (modelSelect)
          modelSelect.value = preset.models[0];
        if (modelCustomRow)
          modelCustomRow.style.display = "none";
      }
      presetWrap.querySelectorAll(".paper-daily-preset-btn").forEach((b) => {
        const el = b;
        if (el.dataset.preset === presetKey) {
          el.style.opacity = "1";
          el.style.fontWeight = "600";
          el.style.borderColor = "var(--interactive-accent)";
          el.style.color = "var(--interactive-accent)";
        } else {
          el.style.opacity = "0.6";
          el.style.fontWeight = "400";
          el.style.borderColor = "var(--background-modifier-border)";
          el.style.color = "var(--text-normal)";
        }
      });
      await this.plugin.saveSettings();
    };
    for (const [key, preset] of Object.entries(PROVIDER_PRESETS)) {
      const btn = presetWrap.createEl("button", {
        text: preset.label,
        cls: "paper-daily-preset-btn"
      });
      btn.dataset.preset = key;
      btn.style.padding = "4px 12px";
      btn.style.borderRadius = "6px";
      btn.style.border = "1px solid var(--background-modifier-border)";
      btn.style.cursor = "pointer";
      btn.style.fontSize = "0.85em";
      btn.style.background = "var(--background-secondary)";
      btn.style.transition = "all 0.15s";
      if (key === activePreset) {
        btn.style.opacity = "1";
        btn.style.fontWeight = "600";
        btn.style.borderColor = "var(--interactive-accent)";
        btn.style.color = "var(--interactive-accent)";
      } else {
        btn.style.opacity = "0.6";
        btn.style.color = "var(--text-normal)";
      }
      btn.addEventListener("click", () => applyPreset(key));
    }
    new import_obsidian.Setting(containerEl).setName("\u63A5\u53E3\u5730\u5740 / Base URL").setDesc("API \u7AEF\u70B9\uFF0C\u9009\u62E9\u9884\u8BBE\u540E\u81EA\u52A8\u586B\u5165 | API endpoint (auto-filled by preset; edit for custom deployments)").addText((text) => {
      baseUrlInput = text.inputEl;
      text.setPlaceholder("https://api.openai.com/v1").setValue(this.plugin.settings.llm.baseUrl).onChange(async (value) => {
        this.plugin.settings.llm.baseUrl = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("API \u5BC6\u94A5 / API Key").setDesc("\u6240\u9009\u670D\u52A1\u5546\u7684 API \u5BC6\u94A5 | Your API key for the selected provider").addText((text) => {
      var _a3, _b2;
      apiKeyInput = text.inputEl;
      text.inputEl.type = "password";
      text.inputEl.placeholder = (_b2 = (_a3 = PROVIDER_PRESETS[activePreset]) == null ? void 0 : _a3.keyPlaceholder) != null ? _b2 : "sk-...";
      text.inputEl.value = this.plugin.settings.llm.apiKey;
      text.inputEl.addEventListener("input", async () => {
        this.plugin.settings.llm.apiKey = text.inputEl.value;
        await this.plugin.saveSettings();
      });
    });
    const modelSetting = new import_obsidian.Setting(containerEl).setName("\u6A21\u578B / Model").setDesc("\u4ECE\u9884\u8BBE\u4E2D\u9009\u62E9\uFF0C\u6216\u9009 Other \u624B\u52A8\u8F93\u5165 | Select a preset model or choose Other to type a custom name");
    modelSetting.controlEl.style.flexDirection = "column";
    modelSetting.controlEl.style.alignItems = "flex-start";
    modelSetting.controlEl.style.gap = "6px";
    modelSelect = modelSetting.controlEl.createEl("select");
    modelSelect.style.width = "100%";
    modelSelect.style.padding = "4px 6px";
    modelSelect.style.borderRadius = "4px";
    modelSelect.style.border = "1px solid var(--background-modifier-border)";
    modelSelect.style.background = "var(--background-primary)";
    modelSelect.style.color = "var(--text-normal)";
    modelSelect.style.fontSize = "0.9em";
    modelCustomRow = modelSetting.controlEl.createDiv();
    modelCustomRow.style.width = "100%";
    modelCustomRow.style.display = "none";
    customModelInput = modelCustomRow.createEl("input", { type: "text" });
    customModelInput.placeholder = "Enter model name...";
    customModelInput.style.width = "100%";
    customModelInput.style.padding = "4px 6px";
    customModelInput.style.borderRadius = "4px";
    customModelInput.style.border = "1px solid var(--background-modifier-border)";
    customModelInput.style.background = "var(--background-primary)";
    customModelInput.style.color = "var(--text-normal)";
    customModelInput.style.fontSize = "0.9em";
    customModelInput.addEventListener("input", async () => {
      this.plugin.settings.llm.model = customModelInput.value;
      await this.plugin.saveSettings();
    });
    renderModelOptions(activePreset);
    modelSelect.addEventListener("change", async () => {
      if (modelSelect.value === "__custom__") {
        modelCustomRow.style.display = "";
        customModelInput.focus();
      } else {
        modelCustomRow.style.display = "none";
        this.plugin.settings.llm.model = modelSelect.value;
        await this.plugin.saveSettings();
      }
    });
    new import_obsidian.Setting(containerEl).setName("\u6E29\u5EA6 / Temperature").setDesc("\u6A21\u578B\u751F\u6210\u6E29\u5EA6\uFF080 = \u786E\u5B9A\u6027\uFF0C1 = \u6700\u5927\u968F\u673A\uFF09| LLM temperature (0.0 = deterministic, 1.0 = most random)").addSlider((slider) => slider.setLimits(0, 1, 0.05).setValue(this.plugin.settings.llm.temperature).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.llm.temperature = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("\u6700\u5927 Token \u6570 / Max Tokens").setDesc("\u6A21\u578B\u5355\u6B21\u54CD\u5E94\u7684\u6700\u5927 token \u6570 | Maximum tokens for LLM response").addSlider((slider) => slider.setLimits(512, 8192, 256).setValue(this.plugin.settings.llm.maxTokens).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.llm.maxTokens = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u8F93\u51FA\u683C\u5F0F / Output" });
    new import_obsidian.Setting(containerEl).setName("\u6839\u76EE\u5F55 / Root Folder").setDesc("Vault \u5185\u6240\u6709 Paper Daily \u6587\u4EF6\u7684\u5B58\u653E\u76EE\u5F55 | Folder inside vault where all Paper Daily files are written").addText((text) => text.setPlaceholder("PaperDaily").setValue(this.plugin.settings.rootFolder).onChange(async (value) => {
      this.plugin.settings.rootFolder = value || "PaperDaily";
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u5B9A\u65F6\u4EFB\u52A1 / Scheduling" });
    new import_obsidian.Setting(containerEl).setName("\u6BCF\u65E5\u6293\u53D6\u65F6\u95F4 / Daily Fetch Time").setDesc("\u6BCF\u5929\u81EA\u52A8\u8FD0\u884C\u7684\u65F6\u95F4\uFF0824 \u5C0F\u65F6\u5236 HH:MM\uFF09| Time to run daily fetch (HH:MM, 24-hour)").addText((text) => text.setPlaceholder("08:30").setValue(this.plugin.settings.schedule.dailyTime).onChange(async (value) => {
      this.plugin.settings.schedule.dailyTime = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h2", { text: "\u5DE5\u5177 / Tools" });
    const testStatusEl = containerEl.createEl("pre", { text: "" });
    testStatusEl.style.color = "var(--text-muted)";
    testStatusEl.style.fontSize = "0.82em";
    testStatusEl.style.whiteSpace = "pre-wrap";
    testStatusEl.style.wordBreak = "break-all";
    testStatusEl.style.background = "var(--background-secondary)";
    testStatusEl.style.padding = "8px 10px";
    testStatusEl.style.borderRadius = "6px";
    testStatusEl.style.minHeight = "1.8em";
    testStatusEl.style.display = "none";
    const setStatus = (text, color = "var(--text-muted)") => {
      testStatusEl.style.display = "";
      testStatusEl.style.color = color;
      testStatusEl.setText(text);
    };
    new import_obsidian.Setting(containerEl).setName("\u7ACB\u5373\u8FD0\u884C\u6BCF\u65E5\u62A5\u544A / Run Daily Report Now").setDesc("\u5B8C\u6574\u6D41\u7A0B\uFF1A\u6293\u53D6 + AI \u6458\u8981 + \u5199\u5165 inbox/\uFF08\u8BF7\u5148\u786E\u8BA4 API Key \u548C\u914D\u7F6E\u6B63\u786E\uFF09| Full pipeline: fetch + AI digest + write to inbox/. Verify your API key first.").addButton((btn) => {
      btn.setButtonText("\u25B6 \u7ACB\u5373\u8FD0\u884C / Run Daily Now").setCta().onClick(() => {
        this.plugin.runDailyWithUI();
      });
    });
    containerEl.createEl("h3", { text: "\u6279\u91CF\u751F\u6210\u65E5\u62A5 / Batch Generate Daily Reports" });
    containerEl.createEl("p", {
      text: "\u6309\u65E5\u671F\u8303\u56F4\u6279\u91CF\u751F\u6210\u6BCF\u65E5\u62A5\u544A\uFF0C\u9002\u5408\u8865\u5168\u5386\u53F2\u8BB0\u5F55 | Generate daily reports for a date range to backfill historical records.",
      cls: "setting-item-description"
    });
    let bfStartDate = "";
    let bfEndDate = "";
    new import_obsidian.Setting(containerEl).setName("\u5F00\u59CB\u65E5\u671F / Start Date").setDesc("YYYY-MM-DD").addText((text) => text.setPlaceholder("2026-02-01").onChange((v) => {
      bfStartDate = v.trim();
    }));
    new import_obsidian.Setting(containerEl).setName("\u7ED3\u675F\u65E5\u671F / End Date").setDesc("YYYY-MM-DD").addText((text) => text.setPlaceholder("2026-02-28").onChange((v) => {
      bfEndDate = v.trim();
    }));
    new import_obsidian.Setting(containerEl).addButton((btn) => btn.setButtonText("\u25B6 \u6279\u91CF\u751F\u6210 / Run Batch").setCta().onClick(() => {
      if (!bfStartDate || !bfEndDate) {
        setStatus("\u8BF7\u586B\u5199\u5F00\u59CB\u548C\u7ED3\u675F\u65E5\u671F\u3002", "var(--color-red)");
        return;
      }
      this.plugin.runBackfillWithUI(bfStartDate, bfEndDate);
    }));
    containerEl.createEl("h2", { text: "\u914D\u7F6E\u6587\u4EF6 / Config File" });
    const configPath = `${this.plugin.settings.rootFolder}/config.json`;
    new import_obsidian.Setting(containerEl).setName("\u914D\u7F6E\u6587\u4EF6\u8DEF\u5F84 / Config File Path").setDesc(`\u6240\u6709\u8BBE\u7F6E\u81EA\u52A8\u540C\u6B65\u5230\u6B64 Vault \u6587\u4EF6\uFF0C\u6362\u8BBE\u5907\u6216\u91CD\u88C5\u63D2\u4EF6\u65F6\u5C06\u4F18\u5148\u4ECE\u6B64\u6587\u4EF6\u8BFB\u53D6\u3002| All settings are auto-synced to this vault file and loaded on startup.`).addText((text) => {
      text.setValue(configPath);
      text.inputEl.readOnly = true;
      text.inputEl.style.width = "100%";
      text.inputEl.style.color = "var(--text-muted)";
      text.inputEl.style.fontFamily = "monospace";
      text.inputEl.style.fontSize = "0.85em";
    });
    new import_obsidian.Setting(containerEl).addButton((btn) => btn.setButtonText("\u7ACB\u5373\u5BFC\u51FA / Export Now").setCta().onClick(async () => {
      await this.plugin.saveSettings();
      new import_obsidian.Notice(`\u914D\u7F6E\u5DF2\u5BFC\u51FA\u5230 ${configPath}`);
    })).addButton((btn) => btn.setButtonText("\u4ECE\u6587\u4EF6\u91CD\u8F7D / Reload from File").onClick(async () => {
      await this.plugin.loadSettings();
      new import_obsidian.Notice("\u5DF2\u4ECE\u914D\u7F6E\u6587\u4EF6\u91CD\u65B0\u52A0\u8F7D\u8BBE\u7F6E\u3002");
      this.display();
    }));
    containerEl.createEl("hr");
    const contactDiv = containerEl.createDiv({ cls: "paper-daily-contact" });
    contactDiv.style.textAlign = "center";
    contactDiv.style.padding = "20px 0 12px";
    contactDiv.style.color = "var(--text-muted)";
    contactDiv.style.fontSize = "0.88em";
    contactDiv.style.lineHeight = "1.8";
    contactDiv.createEl("p", {
      text: "\u{1F916} Paper Daily \u2014 Built for the AI research community"
    }).style.marginBottom = "4px";
    const emailLine = contactDiv.createEl("p");
    emailLine.style.marginBottom = "0";
    emailLine.appendText("\u{1F4EC} \u8054\u7CFB\u4F5C\u8005 / Contact me: ");
    const emailLink = emailLine.createEl("a", {
      text: "astra.jwt@gmail.com",
      href: "mailto:astra.jwt@gmail.com"
    });
    emailLink.style.color = "var(--interactive-accent)";
    emailLink.style.textDecoration = "none";
  }
};

// src/storage/vaultWriter.ts
var import_obsidian2 = require("obsidian");
var VaultWriter = class {
  constructor(app) {
    this.app = app;
  }
  async ensureFolder(folderPath) {
    const normalized = (0, import_obsidian2.normalizePath)(folderPath);
    const existing = this.app.vault.getAbstractFileByPath(normalized);
    if (!existing) {
      await this.app.vault.createFolder(normalized);
    }
  }
  async ensureFolderForFile(filePath) {
    const parts = (0, import_obsidian2.normalizePath)(filePath).split("/");
    parts.pop();
    if (parts.length > 0) {
      await this.ensureFolder(parts.join("/"));
    }
  }
  async writeNote(filePath, content) {
    const normalized = (0, import_obsidian2.normalizePath)(filePath);
    await this.ensureFolderForFile(normalized);
    const existing = this.app.vault.getAbstractFileByPath(normalized);
    if (existing instanceof import_obsidian2.TFile) {
      await this.app.vault.modify(existing, content);
    } else {
      await this.app.vault.create(normalized, content);
    }
  }
  async readNote(filePath) {
    const normalized = (0, import_obsidian2.normalizePath)(filePath);
    const file = this.app.vault.getAbstractFileByPath(normalized);
    if (file instanceof import_obsidian2.TFile) {
      return await this.app.vault.read(file);
    }
    return null;
  }
  async appendToNote(filePath, content) {
    const normalized = (0, import_obsidian2.normalizePath)(filePath);
    await this.ensureFolderForFile(normalized);
    const existing = this.app.vault.getAbstractFileByPath(normalized);
    if (existing instanceof import_obsidian2.TFile) {
      const current = await this.app.vault.read(existing);
      await this.app.vault.modify(existing, current + content);
    } else {
      await this.app.vault.create(normalized, content);
    }
  }
  async fileExists(filePath) {
    const normalized = (0, import_obsidian2.normalizePath)(filePath);
    const file = this.app.vault.getAbstractFileByPath(normalized);
    return file instanceof import_obsidian2.TFile;
  }
  async listFolder(folderPath) {
    const normalized = (0, import_obsidian2.normalizePath)(folderPath);
    const folder = this.app.vault.getAbstractFileByPath(normalized);
    if (folder instanceof import_obsidian2.TFolder) {
      return folder.children.filter((f) => f instanceof import_obsidian2.TFile).map((f) => f.name);
    }
    return [];
  }
};

// src/storage/stateStore.ts
var StateStore = class {
  constructor(writer, rootFolder) {
    this.writer = writer;
    this.path = `${rootFolder}/cache/state.json`;
    this.state = {
      lastDailyRun: "",
      lastError: null
    };
  }
  async load() {
    const content = await this.writer.readNote(this.path);
    if (content) {
      try {
        this.state = JSON.parse(content);
      } catch (e) {
      }
    }
  }
  async save() {
    await this.writer.writeNote(this.path, JSON.stringify(this.state, null, 2));
  }
  get() {
    return { ...this.state };
  }
  async setLastDailyRun(iso) {
    this.state.lastDailyRun = iso;
    await this.save();
  }
  async setLastError(stage, message) {
    this.state.lastError = { time: new Date().toISOString(), stage, message };
    await this.save();
  }
  async clearLastError() {
    this.state.lastError = null;
    await this.save();
  }
};

// src/storage/dedupStore.ts
var DedupStore = class {
  constructor(writer, rootFolder) {
    this.writer = writer;
    this.map = {};
    this.path = `${rootFolder}/cache/seen_ids.json`;
  }
  async load() {
    const content = await this.writer.readNote(this.path);
    if (content) {
      try {
        this.map = JSON.parse(content);
      } catch (e) {
        this.map = {};
      }
    }
  }
  async save() {
    await this.writer.writeNote(this.path, JSON.stringify(this.map, null, 2));
  }
  hasId(id) {
    return id in this.map;
  }
  async markSeen(id, date) {
    if (!this.map[id]) {
      this.map[id] = date;
    }
  }
  async markSeenBatch(ids, date) {
    for (const id of ids) {
      await this.markSeen(id, date);
    }
    await this.save();
  }
  // Remove entries older than keepDays to limit growth
  async prune(keepDays = 90) {
    const cutoff = new Date();
    cutoff.setDate(cutoff.getDate() - keepDays);
    const cutoffStr = cutoff.toISOString().slice(0, 10);
    for (const [id, date] of Object.entries(this.map)) {
      if (date < cutoffStr) {
        delete this.map[id];
      }
    }
    await this.save();
  }
  async clear() {
    this.map = {};
    await this.save();
  }
  size() {
    return Object.keys(this.map).length;
  }
  getMap() {
    return { ...this.map };
  }
};

// src/storage/snapshotStore.ts
var SnapshotStore = class {
  constructor(writer, rootFolder) {
    this.writer = writer;
    this.rootFolder = rootFolder;
  }
  snapshotPath(date) {
    return `${this.rootFolder}/papers/${date}.json`;
  }
  async writeSnapshot(date, papers, error) {
    const snapshot = {
      date,
      papers,
      fetchedAt: new Date().toISOString(),
      error
    };
    await this.writer.writeNote(
      this.snapshotPath(date),
      JSON.stringify(snapshot, null, 2)
    );
  }
  async readSnapshot(date) {
    const content = await this.writer.readNote(this.snapshotPath(date));
    if (!content)
      return null;
    try {
      return JSON.parse(content);
    } catch (e) {
      return null;
    }
  }
  async listSnapshotDates() {
    const files = await this.writer.listFolder(`${this.rootFolder}/papers`);
    return files.filter((f) => f.endsWith(".json")).map((f) => f.replace(".json", "")).sort();
  }
  async readSnapshotsForRange(startDate, endDate) {
    const dates = await this.listSnapshotDates();
    const filtered = dates.filter((d) => d >= startDate && d <= endDate);
    const results = [];
    for (const d of filtered) {
      const snap = await this.readSnapshot(d);
      if (snap)
        results.push(snap);
    }
    return results;
  }
};

// src/storage/hfTrackStore.ts
var HFTrackStore = class {
  constructor(writer, rootFolder) {
    this.writer = writer;
    this.map = {};
    this.path = `${rootFolder}/cache/hf_track.json`;
  }
  async load() {
    const content = await this.writer.readNote(this.path);
    if (content) {
      try {
        this.map = JSON.parse(content);
      } catch (e) {
        this.map = {};
      }
    }
  }
  async save() {
    await this.writer.writeNote(this.path, JSON.stringify(this.map, null, 2));
  }
  // Record that a paper appeared on HF on this date. Returns updated count.
  track(id, title, date) {
    const existing = this.map[id];
    if (existing) {
      if (existing.lastSeen === date)
        return existing.count;
      existing.lastSeen = date;
      existing.count += 1;
      return existing.count;
    }
    this.map[id] = { title, firstSeen: date, lastSeen: date, count: 1 };
    return 1;
  }
  getEntry(id) {
    return this.map[id];
  }
  // Was this paper seen before this date?
  seenBefore(id, date) {
    const e = this.map[id];
    return !!e && e.firstSeen < date;
  }
};

// src/sources/arxivSource.ts
var import_obsidian3 = require("obsidian");
var ArxivSource = class {
  constructor() {
    this.name = "arxiv";
    this.enabled = true;
  }
  buildQuery(categories, keywords) {
    const catParts = categories.map((c) => `cat:${c}`);
    const catClause = catParts.length > 0 ? `(${catParts.join(" OR ")})` : "";
    if (keywords.length === 0) {
      return catClause || "all:*";
    }
    const kwParts = keywords.map((k) => `all:"${k}"`);
    const kwClause = `(${kwParts.join(" OR ")})`;
    return catClause ? `(${catClause}) AND ${kwClause}` : kwClause;
  }
  buildUrl(params, maxResults) {
    const query = this.buildQuery(params.categories, params.keywords);
    const encoded = encodeURIComponent(query);
    const sortOrder = "descending";
    return `https://export.arxiv.org/api/query?search_query=${encoded}&max_results=${maxResults}&sortBy=${params.sortBy}&sortOrder=${sortOrder}`;
  }
  parseAtomEntry(entry) {
    var _a2;
    const getText = (tag) => {
      var _a3, _b;
      const el = entry.querySelector(tag);
      return el ? (_b = (_a3 = el.textContent) == null ? void 0 : _a3.trim()) != null ? _b : "" : "";
    };
    const rawId = getText("id");
    if (!rawId)
      return null;
    const arxivIdMatch = rawId.match(/arxiv\.org\/abs\/([^v]+)(v\d+)?/i);
    const arxivId = arxivIdMatch ? `arxiv:${arxivIdMatch[1]}${(_a2 = arxivIdMatch[2]) != null ? _a2 : ""}`.toLowerCase() : `arxiv:${rawId}`;
    const title = getText("title").replace(/\s+/g, " ");
    const abstract = getText("summary").replace(/\s+/g, " ");
    const published = getText("published");
    const updated = getText("updated");
    const authors = [];
    entry.querySelectorAll("author name").forEach((el) => {
      var _a3;
      const name = (_a3 = el.textContent) == null ? void 0 : _a3.trim();
      if (name)
        authors.push(name);
    });
    const categories = [];
    entry.querySelectorAll("category").forEach((el) => {
      const term = el.getAttribute("term");
      if (term)
        categories.push(term);
    });
    let htmlLink = "";
    let pdfLink = "";
    entry.querySelectorAll("link").forEach((el) => {
      var _a3, _b;
      const rel = el.getAttribute("rel");
      const href = (_a3 = el.getAttribute("href")) != null ? _a3 : "";
      const type = (_b = el.getAttribute("type")) != null ? _b : "";
      if (rel === "alternate" || type === "text/html")
        htmlLink = href;
      if (type === "application/pdf" || href.includes("/pdf/"))
        pdfLink = href;
    });
    return {
      id: arxivId,
      title,
      abstract,
      authors,
      categories,
      published,
      updated,
      links: { html: htmlLink || void 0, pdf: pdfLink || void 0 },
      source: "arxiv"
    };
  }
  filterByWindow(papers, windowStart, windowEnd) {
    return papers.filter((p) => {
      const dateStr = p.published || p.updated;
      if (!dateStr)
        return false;
      const d = new Date(dateStr);
      return d >= windowStart && d <= windowEnd;
    });
  }
  async fetch(params) {
    const maxResults = params.maxResults * 3;
    const url = this.buildUrl(params, maxResults);
    const delays = [5e3, 15e3, 3e4];
    let lastErr;
    for (let attempt = 0; attempt <= delays.length; attempt++) {
      if (attempt > 0) {
        const wait = delays[attempt - 1];
        console.log(`[PaperDaily] arXiv 429, retrying in ${wait / 1e3}s (attempt ${attempt}/${delays.length})...`);
        await new Promise((r) => setTimeout(r, wait));
      }
      try {
        const response = await (0, import_obsidian3.requestUrl)({ url, method: "GET" });
        const xmlText = response.text;
        const parser = new DOMParser();
        const doc = parser.parseFromString(xmlText, "application/xml");
        const parseError = doc.querySelector("parsererror");
        if (parseError) {
          throw new Error(`arXiv XML parse error: ${parseError.textContent}`);
        }
        const entries = Array.from(doc.querySelectorAll("entry"));
        const papers = [];
        for (const entry of entries) {
          const paper = this.parseAtomEntry(entry);
          if (paper)
            papers.push(paper);
        }
        return this.filterByWindow(papers, params.windowStart, params.windowEnd);
      } catch (err) {
        const msg = String(err);
        if (msg.includes("429") && attempt < delays.length) {
          lastErr = err;
          continue;
        }
        throw err;
      }
    }
    throw lastErr;
  }
};

// src/sources/hfSource.ts
var import_obsidian4 = require("obsidian");
var HFSource = class {
  constructor() {
    this.name = "huggingface";
    this.enabled = true;
  }
  // Fetch HF daily papers for a given date (YYYY-MM-DD).
  // Returns Paper[] with hfUpvotes populated.
  async fetchForDate(date) {
    var _a2, _b, _c, _d, _e;
    const url = `https://huggingface.co/api/daily_papers?date=${date}`;
    const response = await (0, import_obsidian4.requestUrl)({ url, method: "GET" });
    const entries = JSON.parse(response.text);
    if (!Array.isArray(entries))
      return [];
    const papers = [];
    for (const entry of entries) {
      const p = entry.paper;
      if (!(p == null ? void 0 : p.id))
        continue;
      const baseId = p.id.trim();
      const authors = ((_a2 = p.authors) != null ? _a2 : []).map((a) => a.name).filter(Boolean);
      const published = (_b = p.publishedAt) != null ? _b : "";
      const htmlLink = `https://arxiv.org/abs/${baseId}`;
      const pdfLink = `https://arxiv.org/pdf/${baseId}`;
      const hfLink = `https://huggingface.co/papers/${baseId}`;
      papers.push({
        id: `arxiv:${baseId}`,
        // normalised without version so we can match
        title: (_c = p.title) != null ? _c : "",
        abstract: (_d = p.summary) != null ? _d : "",
        authors,
        categories: [],
        published,
        updated: published,
        links: { html: htmlLink, pdf: pdfLink, hf: hfLink },
        source: "hf",
        hfUpvotes: (_e = p.upvotes) != null ? _e : 0
      });
    }
    papers.sort((a, b) => {
      var _a3, _b2;
      return ((_a3 = b.hfUpvotes) != null ? _a3 : 0) - ((_b2 = a.hfUpvotes) != null ? _b2 : 0);
    });
    return papers;
  }
  // PaperSource interface: not used in normal pipeline (we call fetchForDate directly)
  async fetch(_params) {
    return [];
  }
};

// src/scoring/interest.ts
function normalize(text) {
  return text.toLowerCase().replace(/\s+/g, " ").trim();
}
function computeInterestHits(paper, keywords) {
  const haystack = normalize(`${paper.title} ${paper.abstract}`);
  return keywords.filter((kw) => haystack.includes(normalize(kw.keyword))).map((kw) => kw.keyword);
}
function computeWeightedInterestScore(paper, keywords) {
  const haystack = normalize(`${paper.title} ${paper.abstract}`);
  return keywords.filter((kw) => haystack.includes(normalize(kw.keyword))).reduce((sum, kw) => sum + kw.weight, 0);
}

// src/scoring/rank.ts
function rankPapers(papers, interestKeywords) {
  const scored = papers.map((paper) => {
    var _a2;
    const interestHits = computeInterestHits(paper, interestKeywords);
    const interestScore = computeWeightedInterestScore(paper, interestKeywords);
    const hfScore = Math.log1p((_a2 = paper.hfUpvotes) != null ? _a2 : 0) * 10;
    const rankScore = hfScore + interestScore;
    return {
      ...paper,
      interestHits,
      _rankScore: rankScore
    };
  });
  scored.sort((a, b) => {
    if (Math.abs(b._rankScore - a._rankScore) > 1e-3)
      return b._rankScore - a._rankScore;
    const dateA = new Date(a.updated || a.published).getTime();
    const dateB = new Date(b.updated || b.published).getTime();
    return dateB - dateA;
  });
  return scored.map(({ _rankScore: _r, ...paper }) => paper);
}

// src/storage/paperDownloader.ts
var import_obsidian5 = require("obsidian");
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function getArxivId(paperId) {
  return paperId.replace(/^arxiv:/i, "");
}
function safeFilename(id) {
  return id.replace(/[/\\:*?"<>|]/g, "_");
}
async function ensureFolder(app, folderPath) {
  if (!folderPath)
    return;
  const normalized = (0, import_obsidian5.normalizePath)(folderPath);
  if (app.vault.getAbstractFileByPath(normalized))
    return;
  const parent = normalized.split("/").slice(0, -1).join("/");
  if (parent)
    await ensureFolder(app, parent);
  try {
    await app.vault.createFolder(normalized);
  } catch (e) {
  }
}
async function downloadOne(app, paper, rootFolder, date, log) {
  const arxivId = getArxivId(paper.id);
  const filename = safeFilename(arxivId);
  if (!paper.links.pdf)
    return;
  const pdfFolder = `${rootFolder}/papers/pdf/${date}`;
  const pdfPath = (0, import_obsidian5.normalizePath)(`${pdfFolder}/${filename}.pdf`);
  if (app.vault.getAbstractFileByPath(pdfPath)) {
    paper.links.localPdf = pdfPath;
    log(`PDF skip (exists): ${filename}`);
  } else {
    try {
      const resp = await (0, import_obsidian5.requestUrl)({ url: paper.links.pdf, method: "GET" });
      if (resp.status === 200) {
        await ensureFolder(app, pdfFolder);
        await app.vault.adapter.writeBinary(pdfPath, resp.arrayBuffer);
        paper.links.localPdf = pdfPath;
        log(`PDF saved: ${filename}.pdf (${Math.round(resp.arrayBuffer.byteLength / 1024)} KB)`);
      } else {
        log(`PDF skip (HTTP ${resp.status}): ${filename}`);
      }
    } catch (err) {
      log(`PDF error: ${filename}: ${String(err)}`);
    }
    await sleep(1200);
  }
}
async function downloadPapersForDay(app, papers, settings, log, date) {
  var _a2;
  if (!((_a2 = settings.paperDownload) == null ? void 0 : _a2.savePdf))
    return;
  log(`Step DOWNLOAD: ${papers.length} papers \u2192 papers/pdf/${date}/`);
  for (const paper of papers) {
    await downloadOne(app, paper, settings.rootFolder, date, log);
  }
  log(`Step DOWNLOAD: done`);
}

// src/llm/openaiCompatible.ts
var import_obsidian6 = require("obsidian");
var OpenAICompatibleProvider = class {
  constructor(baseUrl, apiKey, model) {
    this.baseUrl = baseUrl;
    this.apiKey = apiKey;
    this.model = model;
  }
  async generate(input) {
    var _a2, _b, _c, _d, _e, _f, _g, _h;
    const messages = [];
    if (input.system) {
      messages.push({ role: "system", content: input.system });
    }
    messages.push({ role: "user", content: input.prompt });
    const body = {
      model: this.model,
      messages,
      temperature: (_a2 = input.temperature) != null ? _a2 : 0.3,
      max_tokens: (_b = input.maxTokens) != null ? _b : 4096
    };
    const url = this.baseUrl.replace(/\/$/, "") + "/chat/completions";
    const response = await (0, import_obsidian6.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`
      },
      body: JSON.stringify(body)
    });
    const json = response.json;
    const text = (_f = (_e = (_d = (_c = json == null ? void 0 : json.choices) == null ? void 0 : _c[0]) == null ? void 0 : _d.message) == null ? void 0 : _e.content) != null ? _f : "";
    const usage = (json == null ? void 0 : json.usage) ? {
      inputTokens: (_g = json.usage.prompt_tokens) != null ? _g : 0,
      outputTokens: (_h = json.usage.completion_tokens) != null ? _h : 0
    } : void 0;
    return { text, usage, raw: json };
  }
};

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION = "0.36.3";

// node_modules/@anthropic-ai/sdk/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` before importing anything else from @anthropic-ai/sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import '@anthropic-ai/sdk/shims/${shims.kind}'\` after \`import '@anthropic-ai/sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/@anthropic-ai/sdk/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/@anthropic-ai/sdk/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from '@anthropic-ai/sdk'\`:
- \`import '@anthropic-ai/sdk/shims/node'\` (if you're running on Node)
- \`import '@anthropic-ai/sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/anthropics/anthropic-sdk-typescript#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/@anthropic-ai/sdk/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/@anthropic-ai/sdk/error.mjs
var AnthropicError = class extends Error {
};
var APIError = class extends AnthropicError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.request_id = headers == null ? void 0 : headers["request-id"];
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new AnthropicError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new AnthropicError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new AnthropicError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;

// node_modules/@anthropic-ai/sdk/internal/stream-utils.mjs
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/@anthropic-ai/sdk/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (sse.event === "completion") {
            try {
              yield JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
          }
          if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
            try {
              yield JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
          }
          if (sse.event === "ping") {
            continue;
          }
          if (sse.event === "error") {
            throw APIError.generate(void 0, `SSE Error: ${sse.data}`, sse.data, createResponseHeaders(response.headers));
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}

// node_modules/@anthropic-ai/sdk/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
async function toFile(value, name, options) {
  var _a2, _b, _c;
  value = await value;
  if (isFileLike(value)) {
    return value;
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File2(data, name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!(options == null ? void 0 : options.type)) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";

// node_modules/@anthropic-ai/sdk/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return _addRequestID(json, response);
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
function _addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => _addRequestID(transform(await this.parseResponse(props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import â€¦ from '@anthropic-ai/sdk'`:
   * - `import '@anthropic-ai/sdk/shims/node'` (if you're running on Node)
   * - `import '@anthropic-ai/sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e5,
    // 10 minutes
    httpAgent,
    fetch: overriddenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overriddenFetch != null ? overriddenFetch : fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2 == null ? void 0 : opts2.body) ? new DataView(await opts2.body.arrayBuffer()) : (opts2 == null ? void 0 : opts2.body) instanceof DataView ? opts2.body : (opts2 == null ? void 0 : opts2.body) instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2 == null ? void 0 : opts2.body) ? new DataView(opts2.body.buffer) : opts2 == null ? void 0 : opts2.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page2, opts) {
    return this.requestAPIList(Page2, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === void 0 && getHeader(headers, "x-stainless-retry-count") === void 0) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page2, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page2);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const fetchOptions = {
      signal: controller.signal,
      ...options
    };
    if (fetchOptions.method) {
      fetchOptions.method = fetchOptions.method.toUpperCase();
    }
    return (
      // use undefined this binding; fetch errors if bound to something else in browser/cloudflare
      this.fetch.call(void 0, url, fetchOptions).finally(() => {
        clearTimeout(timeout);
      })
    );
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page2) {
    super(request, async (props) => new Page2(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var requestOptionsKeys = {
  method: true,
  path: true,
  query: true,
  body: true,
  headers: true,
  maxRetries: true,
  stream: true,
  timeout: true,
  httpAgent: true,
  signal: true,
  idempotencyKey: true,
  __binaryRequest: true,
  __binaryResponse: true,
  __streamClass: true
};
var isRequestOptions = (obj) => {
  return typeof obj === "object" && obj !== null && !isEmptyObj(obj) && Object.keys(obj).every((k) => hasOwn(requestOptionsKeys, k));
};
var getPlatformProperties = () => {
  var _a2, _b;
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a2 = Deno.version) == null ? void 0 : _a2.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new AnthropicError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new AnthropicError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch (e) {
    }
  }
  return new Error(String(err));
};
var readEnv = (env) => {
  var _a2, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  var _a2;
  if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.env) == null ? void 0 : _a2["DEBUG"]) === "true") {
    console.log(`Anthropic:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
var isHeadersProtocol = (headers) => {
  return typeof (headers == null ? void 0 : headers.get) === "function";
};
var getHeader = (headers, header) => {
  var _a2;
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = ((_a2 = header[0]) == null ? void 0 : _a2.toUpperCase()) + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value = headers.get(key);
      if (value) {
        return value;
      }
    }
  }
  for (const [key, value] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value)) {
        if (value.length <= 1)
          return value[0];
        console.warn(`Received ${value.length} entries for the ${header} header, using the first entry.`);
        return value[0];
      }
      return value;
    }
  }
  return void 0;
};

// node_modules/@anthropic-ai/sdk/pagination.mjs
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.first_id = body.first_id || null;
    this.last_id = body.last_id || null;
  }
  getPaginatedItems() {
    var _a2;
    return (_a2 = this.data) != null ? _a2 : [];
  }
  // @deprecated Please use `nextPageInfo()` instead
  nextPageParams() {
    const info = this.nextPageInfo();
    if (!info)
      return null;
    if ("params" in info)
      return info.params;
    const params = Object.fromEntries(info.url.searchParams);
    if (!Object.keys(params).length)
      return null;
    return params;
  }
  nextPageInfo() {
    var _a2;
    if ((_a2 = this.options.query) == null ? void 0 : _a2["before_id"]) {
      const firstId = this.first_id;
      if (!firstId) {
        return null;
      }
      return {
        params: {
          before_id: firstId
        }
      };
    }
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      params: {
        after_id: cursor
      }
    };
  }
};

// node_modules/@anthropic-ai/sdk/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelId, options) {
    return this._client.get(`/v1/models/${modelId}?beta=true`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/v1/models?beta=true", BetaModelInfosPage, { query, ...options });
  }
};
var BetaModelInfosPage = class extends Page {
};
Models.BetaModelInfosPage = BetaModelInfosPage;

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  async *decoder() {
    const lineDecoder = new LineDecoder();
    for await (const chunk of this.iterator) {
      for (const line of lineDecoder.decode(chunk)) {
        yield JSON.parse(line);
      }
    }
    for (const line of lineDecoder.flush()) {
      yield JSON.parse(line);
    }
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(response, controller) {
    if (!response.body) {
      controller.abort();
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    return new JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   */
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/batches?beta=true", {
      body,
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
        ...options == null ? void 0 : options.headers
      }
    });
  }
  retrieve(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.retrieve(messageBatchId, {}, params);
    }
    const { betas } = params;
    return this._client.get(`/v1/messages/batches/${messageBatchId}?beta=true`, {
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
        ...options == null ? void 0 : options.headers
      }
    });
  }
  list(params = {}, options) {
    if (isRequestOptions(params)) {
      return this.list({}, params);
    }
    const { betas, ...query } = params;
    return this._client.getAPIList("/v1/messages/batches?beta=true", BetaMessageBatchesPage, {
      query,
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
        ...options == null ? void 0 : options.headers
      }
    });
  }
  delete(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.delete(messageBatchId, {}, params);
    }
    const { betas } = params;
    return this._client.delete(`/v1/messages/batches/${messageBatchId}?beta=true`, {
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
        ...options == null ? void 0 : options.headers
      }
    });
  }
  cancel(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.cancel(messageBatchId, {}, params);
    }
    const { betas } = params;
    return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel?beta=true`, {
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
        ...options == null ? void 0 : options.headers
      }
    });
  }
  async results(messageBatchId, params = {}, options) {
    if (isRequestOptions(params)) {
      return this.results(messageBatchId, {}, params);
    }
    const batch = await this.retrieve(messageBatchId);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    const { betas } = params;
    return this._client.get(batch.results_url, {
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
        Accept: "application/binary",
        ...options == null ? void 0 : options.headers
      },
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};
var BetaMessageBatchesPage = class extends Page {
};
Batches.BetaMessageBatchesPage = BetaMessageBatchesPage;

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize = (input) => {
  let current = 0;
  let tokens = [];
  while (current < input.length) {
    let char = input[current];
    if (char === "\\") {
      current++;
      continue;
    }
    if (char === "{") {
      tokens.push({
        type: "brace",
        value: "{"
      });
      current++;
      continue;
    }
    if (char === "}") {
      tokens.push({
        type: "brace",
        value: "}"
      });
      current++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "paren",
        value: "["
      });
      current++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "paren",
        value: "]"
      });
      current++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "separator",
        value: ":"
      });
      current++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "delimiter",
        value: ","
      });
      current++;
      continue;
    }
    if (char === '"') {
      let value = "";
      let danglingQuote = false;
      char = input[++current];
      while (char !== '"') {
        if (current === input.length) {
          danglingQuote = true;
          break;
        }
        if (char === "\\") {
          current++;
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          value += char + input[current];
          char = input[++current];
        } else {
          value += char;
          char = input[++current];
        }
      }
      char = input[++current];
      if (!danglingQuote) {
        tokens.push({
          type: "string",
          value
        });
      }
      continue;
    }
    let WHITESPACE = /\s/;
    if (char && WHITESPACE.test(char)) {
      current++;
      continue;
    }
    let NUMBERS = /[0-9]/;
    if (char && NUMBERS.test(char) || char === "-" || char === ".") {
      let value = "";
      if (char === "-") {
        value += char;
        char = input[++current];
      }
      while (char && NUMBERS.test(char) || char === ".") {
        value += char;
        char = input[++current];
      }
      tokens.push({
        type: "number",
        value
      });
      continue;
    }
    let LETTERS = /[a-z]/i;
    if (char && LETTERS.test(char)) {
      let value = "";
      while (char && LETTERS.test(char)) {
        if (current === input.length) {
          break;
        }
        value += char;
        char = input[++current];
      }
      if (value == "true" || value == "false" || value === "null") {
        tokens.push({
          type: "name",
          value
        });
      } else {
        current++;
        continue;
      }
      continue;
    }
    current++;
  }
  return tokens;
};
var strip = (tokens) => {
  if (tokens.length === 0) {
    return tokens;
  }
  let lastToken = tokens[tokens.length - 1];
  switch (lastToken.type) {
    case "separator":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
    case "number":
      let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
      if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
    case "string":
      let tokenBeforeTheLastToken = tokens[tokens.length - 2];
      if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
      break;
    case "delimiter":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
  }
  return tokens;
};
var unstrip = (tokens) => {
  let tail = [];
  tokens.map((token) => {
    if (token.type === "brace") {
      if (token.value === "{") {
        tail.push("}");
      } else {
        tail.splice(tail.lastIndexOf("}"), 1);
      }
    }
    if (token.type === "paren") {
      if (token.value === "[") {
        tail.push("]");
      } else {
        tail.splice(tail.lastIndexOf("]"), 1);
      }
    }
  });
  if (tail.length > 0) {
    tail.reverse().map((item) => {
      if (item === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
      } else if (item === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
      }
    });
  }
  return tokens;
};
var generate = (tokens) => {
  let output = "";
  tokens.map((token) => {
    switch (token.type) {
      case "string":
        output += '"' + token.value + '"';
        break;
      default:
        output += token.value;
        break;
    }
  });
  return output;
};
var partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
var __classPrivateFieldSet2 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _BetaMessageStream_instances;
var _BetaMessageStream_currentMessageSnapshot;
var _BetaMessageStream_connectedPromise;
var _BetaMessageStream_resolveConnectedPromise;
var _BetaMessageStream_rejectConnectedPromise;
var _BetaMessageStream_endPromise;
var _BetaMessageStream_resolveEndPromise;
var _BetaMessageStream_rejectEndPromise;
var _BetaMessageStream_listeners;
var _BetaMessageStream_ended;
var _BetaMessageStream_errored;
var _BetaMessageStream_aborted;
var _BetaMessageStream_catchingPromiseCreated;
var _BetaMessageStream_response;
var _BetaMessageStream_request_id;
var _BetaMessageStream_getFinalMessage;
var _BetaMessageStream_getFinalText;
var _BetaMessageStream_handleError;
var _BetaMessageStream_beginRequest;
var _BetaMessageStream_addStreamEvent;
var _BetaMessageStream_endRequest;
var _BetaMessageStream_accumulateMessage;
var JSON_BUF_PROPERTY = "__json_buf";
var BetaMessageStream = class {
  constructor() {
    _BetaMessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _BetaMessageStream_connectedPromise.set(this, void 0);
    _BetaMessageStream_resolveConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_rejectConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_endPromise.set(this, void 0);
    _BetaMessageStream_resolveEndPromise.set(this, () => {
    });
    _BetaMessageStream_rejectEndPromise.set(this, () => {
    });
    _BetaMessageStream_listeners.set(this, {});
    _BetaMessageStream_ended.set(this, false);
    _BetaMessageStream_errored.set(this, false);
    _BetaMessageStream_aborted.set(this, false);
    _BetaMessageStream_catchingPromiseCreated.set(this, false);
    _BetaMessageStream_response.set(this, void 0);
    _BetaMessageStream_request_id.set(this, void 0);
    _BetaMessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet2(this, _BetaMessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet2(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _BetaMessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new BetaMessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new BetaMessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet2(this, _BetaMessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
    const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
    this._connected(response);
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _BetaMessageStream_response, response, "f");
    __classPrivateFieldSet2(this, _BetaMessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
    __classPrivateFieldGet2(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _BetaMessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet2(this, _BetaMessageStream_ended, true, "f");
      __classPrivateFieldGet2(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
    this._connected(null);
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
  }
  [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
  }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
    var _a2;
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
            }
            break;
          }
          case "input_json_delta": {
            if (content.type === "tool_use" && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
    var _a2;
    let snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              snapshotContent.text += event.delta.text;
            }
            break;
          }
          case "citations_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
              snapshotContent.citations.push(event.delta.citation);
            }
            break;
          }
          case "input_json_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
              jsonBuf += event.delta.partial_json;
              Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                snapshotContent.input = partialParse(jsonBuf);
              }
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever(x) {
}

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
var Messages = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches(this._client);
  }
  create(params, options) {
    var _a2, _b;
    const { betas, ...body } = params;
    if (body.model in DEPRECATED_MODELS) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    return this._client.post("/v1/messages?beta=true", {
      body,
      timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
      ...options,
      headers: {
        ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0,
        ...options == null ? void 0 : options.headers
      },
      stream: (_b = params.stream) != null ? _b : false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return BetaMessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   */
  countTokens(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body,
      ...options,
      headers: {
        "anthropic-beta": [...betas != null ? betas : [], "token-counting-2024-11-01"].toString(),
        ...options == null ? void 0 : options.headers
      }
    });
  }
};
Messages.Batches = Batches;
Messages.BetaMessageBatchesPage = BetaMessageBatchesPage;

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.models = new Models(this._client);
    this.messages = new Messages(this._client);
  }
};
Beta.Models = Models;
Beta.BetaModelInfosPage = BetaModelInfosPage;
Beta.Messages = Messages;

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2, _b;
    return this._client.post("/v1/complete", {
      body,
      timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
      ...options,
      stream: (_b = body.stream) != null ? _b : false
    });
  }
};

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2 = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   */
  create(body, options) {
    return this._client.post("/v1/messages/batches", { body, ...options });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   */
  retrieve(messageBatchId, options) {
    return this._client.get(`/v1/messages/batches/${messageBatchId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/v1/messages/batches", MessageBatchesPage, { query, ...options });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   */
  delete(messageBatchId, options) {
    return this._client.delete(`/v1/messages/batches/${messageBatchId}`, options);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   */
  cancel(messageBatchId, options) {
    return this._client.post(`/v1/messages/batches/${messageBatchId}/cancel`, options);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   */
  async results(messageBatchId, options) {
    const batch = await this.retrieve(messageBatchId);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    return this._client.get(batch.results_url, {
      ...options,
      headers: {
        Accept: "application/binary",
        ...options == null ? void 0 : options.headers
      },
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};
var MessageBatchesPage = class extends Page {
};
Batches2.MessageBatchesPage = MessageBatchesPage;

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
var __classPrivateFieldSet3 = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _MessageStream_instances;
var _MessageStream_currentMessageSnapshot;
var _MessageStream_connectedPromise;
var _MessageStream_resolveConnectedPromise;
var _MessageStream_rejectConnectedPromise;
var _MessageStream_endPromise;
var _MessageStream_resolveEndPromise;
var _MessageStream_rejectEndPromise;
var _MessageStream_listeners;
var _MessageStream_ended;
var _MessageStream_errored;
var _MessageStream_aborted;
var _MessageStream_catchingPromiseCreated;
var _MessageStream_response;
var _MessageStream_request_id;
var _MessageStream_getFinalMessage;
var _MessageStream_getFinalText;
var _MessageStream_handleError;
var _MessageStream_beginRequest;
var _MessageStream_addStreamEvent;
var _MessageStream_endRequest;
var _MessageStream_accumulateMessage;
var JSON_BUF_PROPERTY2 = "__json_buf";
var MessageStream = class {
  constructor() {
    _MessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _MessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _MessageStream_connectedPromise.set(this, void 0);
    _MessageStream_resolveConnectedPromise.set(this, () => {
    });
    _MessageStream_rejectConnectedPromise.set(this, () => {
    });
    _MessageStream_endPromise.set(this, void 0);
    _MessageStream_resolveEndPromise.set(this, () => {
    });
    _MessageStream_rejectEndPromise.set(this, () => {
    });
    _MessageStream_listeners.set(this, {});
    _MessageStream_ended.set(this, false);
    _MessageStream_errored.set(this, false);
    _MessageStream_aborted.set(this, false);
    _MessageStream_catchingPromiseCreated.set(this, false);
    _MessageStream_response.set(this, void 0);
    _MessageStream_request_id.set(this, void 0);
    _MessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet3(this, _MessageStream_errored, true, "f");
      if (error instanceof Error && error.name === "AbortError") {
        error = new APIUserAbortError();
      }
      if (error instanceof APIUserAbortError) {
        __classPrivateFieldSet3(this, _MessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet3(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet3(this, _MessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet3(this, _MessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet3(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet3(this, _MessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet3(this, _MessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet3(this, _MessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet3(this, _MessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet3(this, _MessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet3(this, _MessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new MessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new MessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet3(this, _MessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
    const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
    this._connected(response);
    for await (const event of stream) {
      __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _MessageStream_response, response, "f");
    __classPrivateFieldSet3(this, _MessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
    __classPrivateFieldGet3(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet3(this, _MessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet3(this, _MessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet3(this, _MessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet3(this, _MessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet3(this, _MessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet3(this, _MessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet3(this, _MessageStream_ended, true, "f");
      __classPrivateFieldGet3(this, _MessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet3(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet3(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet3(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet3(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    var _a2;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
    this._connected(null);
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
    }
    if ((_a2 = stream.controller.signal) == null ? void 0 : _a2.aborted) {
      throw new APIUserAbortError();
    }
    __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
  }
  [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
    var _a2;
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet3(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, (_a2 = content.citations) != null ? _a2 : []);
            }
            break;
          }
          case "input_json_delta": {
            if (content.type === "tool_use" && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
    var _a2;
    let snapshot = __classPrivateFieldGet3(this, _MessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              snapshotContent.text += event.delta.text;
            }
            break;
          }
          case "citations_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              (_a2 = snapshotContent.citations) != null ? _a2 : snapshotContent.citations = [];
              snapshotContent.citations.push(event.delta.citation);
            }
            break;
          }
          case "input_json_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "tool_use") {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
              jsonBuf += event.delta.partial_json;
              Object.defineProperty(snapshotContent, JSON_BUF_PROPERTY2, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                snapshotContent.input = partialParse(jsonBuf);
              }
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever2(x) {
}

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches2(this._client);
  }
  create(body, options) {
    var _a2, _b;
    if (body.model in DEPRECATED_MODELS2) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    return this._client.post("/v1/messages", {
      body,
      timeout: (_a2 = this._client._options.timeout) != null ? _a2 : 6e5,
      ...options,
      stream: (_b = body.stream) != null ? _b : false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return MessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   */
  countTokens(body, options) {
    return this._client.post("/v1/messages/count_tokens", { body, ...options });
  }
};
var DEPRECATED_MODELS2 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025"
};
Messages2.Batches = Batches2;
Messages2.MessageBatchesPage = MessageBatchesPage;

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2 = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelId, options) {
    return this._client.get(`/v1/models/${modelId}`, options);
  }
  list(query = {}, options) {
    if (isRequestOptions(query)) {
      return this.list({}, query);
    }
    return this._client.getAPIList("/v1/models", ModelInfosPage, { query, ...options });
  }
};
var ModelInfosPage = class extends Page {
};
Models2.ModelInfosPage = ModelInfosPage;

// node_modules/@anthropic-ai/sdk/index.mjs
var _a;
var Anthropic = class extends APIClient {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = ((_a2) => (_a2 = readEnv("ANTHROPIC_API_KEY")) != null ? _a2 : null)(), authToken = ((_b) => (_b = readEnv("ANTHROPIC_AUTH_TOKEN")) != null ? _b : null)(), ...opts } = {}) {
    var _a3;
    const options = {
      apiKey,
      authToken,
      ...opts,
      baseURL: baseURL || `https://api.anthropic.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a3 = options.timeout) != null ? _a3 : 6e5,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.completions = new Completions(this);
    this.messages = new Messages2(this);
    this.models = new Models2(this);
    this.beta = new Beta(this);
    this._options = options;
    this.apiKey = apiKey;
    this.authToken = authToken;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
      "anthropic-version": "2023-06-01",
      ...this._options.defaultHeaders
    };
  }
  validateHeaders(headers, customHeaders) {
    if (this.apiKey && headers["x-api-key"]) {
      return;
    }
    if (customHeaders["x-api-key"] === null) {
      return;
    }
    if (this.authToken && headers["authorization"]) {
      return;
    }
    if (customHeaders["authorization"] === null) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  authHeaders(opts) {
    const apiKeyAuth = this.apiKeyAuth(opts);
    const bearerAuth = this.bearerAuth(opts);
    if (apiKeyAuth != null && !isEmptyObj(apiKeyAuth)) {
      return apiKeyAuth;
    }
    if (bearerAuth != null && !isEmptyObj(bearerAuth)) {
      return bearerAuth;
    }
    return {};
  }
  apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return {};
    }
    return { "X-Api-Key": this.apiKey };
  }
  bearerAuth(opts) {
    if (this.authToken == null) {
      return {};
    }
    return { Authorization: `Bearer ${this.authToken}` };
  }
};
_a = Anthropic;
Anthropic.Anthropic = _a;
Anthropic.HUMAN_PROMPT = "\n\nHuman:";
Anthropic.AI_PROMPT = "\n\nAssistant:";
Anthropic.DEFAULT_TIMEOUT = 6e5;
Anthropic.AnthropicError = AnthropicError;
Anthropic.APIError = APIError;
Anthropic.APIConnectionError = APIConnectionError;
Anthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
Anthropic.APIUserAbortError = APIUserAbortError;
Anthropic.NotFoundError = NotFoundError;
Anthropic.ConflictError = ConflictError;
Anthropic.RateLimitError = RateLimitError;
Anthropic.BadRequestError = BadRequestError;
Anthropic.AuthenticationError = AuthenticationError;
Anthropic.InternalServerError = InternalServerError;
Anthropic.PermissionDeniedError = PermissionDeniedError;
Anthropic.UnprocessableEntityError = UnprocessableEntityError;
Anthropic.toFile = toFile;
Anthropic.fileFromPath = fileFromPath;
Anthropic.Completions = Completions;
Anthropic.Messages = Messages2;
Anthropic.Models = Models2;
Anthropic.ModelInfosPage = ModelInfosPage;
Anthropic.Beta = Beta;
var { HUMAN_PROMPT, AI_PROMPT } = Anthropic;
var sdk_default = Anthropic;

// src/llm/anthropicProvider.ts
var AnthropicProvider = class {
  constructor(apiKey, model) {
    this.apiKey = apiKey;
    this.model = model;
    this.client = new sdk_default({ apiKey, dangerouslyAllowBrowser: true });
  }
  async generate(input) {
    var _a2, _b, _c, _d, _e, _f;
    const userContent = [];
    if (input.pdfBase64) {
      userContent.push({
        type: "document",
        source: { type: "base64", media_type: "application/pdf", data: input.pdfBase64 }
      });
    }
    userContent.push({ type: "text", text: input.prompt });
    const response = await this.client.messages.create({
      model: this.model,
      max_tokens: (_a2 = input.maxTokens) != null ? _a2 : 4096,
      temperature: (_b = input.temperature) != null ? _b : 0.3,
      system: input.system,
      messages: [{ role: "user", content: userContent }]
    });
    const textBlock = response.content.find((b) => b.type === "text");
    const text = (textBlock == null ? void 0 : textBlock.type) === "text" ? textBlock.text : "";
    const usage = {
      inputTokens: (_d = (_c = response.usage) == null ? void 0 : _c.input_tokens) != null ? _d : 0,
      outputTokens: (_f = (_e = response.usage) == null ? void 0 : _e.output_tokens) != null ? _f : 0
    };
    return { text, usage, raw: response };
  }
};

// src/pipeline/dailyPipeline.ts
function getISODate(d) {
  return d.toISOString().slice(0, 10);
}
function buildLLMProvider(settings) {
  if (settings.llm.provider === "anthropic") {
    return new AnthropicProvider(settings.llm.apiKey, settings.llm.model);
  }
  return new OpenAICompatibleProvider(settings.llm.baseUrl, settings.llm.apiKey, settings.llm.model);
}
function fillTemplate(template, vars) {
  let result = template;
  for (const [k, v] of Object.entries(vars)) {
    result = result.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
  }
  return result;
}
function getActivePrompt(settings) {
  if (settings.promptLibrary && settings.activePromptId) {
    const tpl = settings.promptLibrary.find((t) => t.id === settings.activePromptId);
    if (tpl)
      return tpl.prompt;
  }
  return settings.llm.dailyPromptTemplate;
}
function getActiveScoringPrompt(settings) {
  var _a2;
  if (settings.promptLibrary && settings.activeScorePromptId) {
    const tpl = settings.promptLibrary.find((t) => t.id === settings.activeScorePromptId);
    if (tpl)
      return tpl.prompt;
  }
  return (_a2 = settings.scoringPromptTemplate) != null ? _a2 : DEFAULT_SCORING_PROMPT;
}
function getActiveDeepReadPrompt(settings) {
  var _a2, _b;
  if (settings.promptLibrary && settings.activeDeepReadPromptId) {
    const tpl = settings.promptLibrary.find((t) => t.id === settings.activeDeepReadPromptId);
    if (tpl)
      return tpl.prompt;
  }
  return (_b = (_a2 = settings.deepRead) == null ? void 0 : _a2.deepReadPromptTemplate) != null ? _b : DEFAULT_DEEP_READ_PROMPT;
}
function escapeTableCell(s) {
  return s.replace(/\|/g, "\\|").replace(/\n/g, " ").replace(/\r/g, "").trim();
}
function buildDeepReadFileName(template, paper, baseId, date, modelName) {
  var _a2;
  const safeStr = (s, maxLen = 60) => s.replace(/[/\\:*?"<>|]/g, "-").replace(/\s+/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "").slice(0, maxLen);
  const [year, month, day] = date.split("-");
  const modelShort = (_a2 = modelName.split("/").pop()) != null ? _a2 : modelName;
  const vars = {
    title: safeStr(paper.title),
    arxivId: baseId,
    date,
    model: safeStr(modelShort, 40),
    year,
    month,
    day
  };
  let result = template;
  for (const [k, v] of Object.entries(vars)) {
    result = result.replace(new RegExp(`\\{\\{${k}\\}\\}`, "g"), v);
  }
  return result.replace(/[/\\:*?"<>|]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "") || baseId;
}
function buildDailyMarkdown(date, settings, rankedPapers, aiDigest, activeSources, domainSummary, error) {
  var _a2, _b;
  const frontmatter = [
    "---",
    "type: paper-daily",
    `date: ${date}`,
    `sources: [${activeSources.join(", ")}]`,
    `categories: [${settings.categories.join(", ")}]`,
    `interestKeywords: [${settings.interestKeywords.map((k) => `${k.keyword}(${k.weight})`).join(", ")}]`,
    "---"
  ].join("\n");
  const header = `# Paper Daily \u2014 ${date}`;
  const modelAttr = error ? "" : ` | by ${settings.llm.model} \u8001\u5E08 \u{1F916}`;
  const digestSection = error ? `## \u4ECA\u65E5\u8981\u70B9\uFF08AI \u603B\u7ED3\uFF09

> **Error**: ${error}` : `## \u4ECA\u65E5\u8981\u70B9\uFF08AI \u603B\u7ED3\uFF09${modelAttr}

${aiDigest}`;
  const deepReadFolder = (_b = (_a2 = settings.deepRead) == null ? void 0 : _a2.outputFolder) != null ? _b : "PaperDaily/deep-read";
  const tableRows = rankedPapers.map((p, i) => {
    var _a3, _b2, _c, _d;
    const titleLink = p.links.html ? `[${escapeTableCell(p.title)}](${p.links.html})` : escapeTableCell(p.title);
    const linkParts = [];
    if (p.links.html)
      linkParts.push(`[arXiv](${p.links.html})`);
    if (p.links.hf)
      linkParts.push(`[\u{1F917} HF](${p.links.hf})`);
    if (settings.includePdfLink && p.links.pdf)
      linkParts.push(`[PDF](${p.links.pdf})`);
    if (p.links.localPdf)
      linkParts.push(`[[${p.links.localPdf}\\|Local PDF]]`);
    if (p.deepReadAnalysis) {
      const baseId = p.id.replace(/^arxiv:/i, "").replace(/v\d+$/i, "");
      const fnTemplate = ((_b2 = (_a3 = settings.deepRead) == null ? void 0 : _a3.fileNameTemplate) == null ? void 0 : _b2.trim()) || "{{title}}-deep-read-{{model}}";
      const fileName = buildDeepReadFileName(fnTemplate, p, baseId, date, settings.llm.model);
      linkParts.push(`[[${deepReadFolder}/${date}/${fileName}\\|Deep Read]]`);
    }
    const score = p.llmScore != null ? `\u2B50${p.llmScore}/10` : "-";
    const summary = escapeTableCell((_c = p.llmSummary) != null ? _c : "");
    const hits = ((_d = p.interestHits) != null ? _d : []).slice(0, 3).join(", ") || "-";
    return `| ${i + 1} | ${titleLink} | ${linkParts.join(" ")} | ${score} | ${summary} | ${hits} |`;
  });
  const allPapersTableSection = [
    "## All Papers",
    "",
    "| # | Title | Links | Score | Summary | Hits |",
    "|---|-------|-------|-------|---------|------|",
    ...tableRows.length > 0 ? tableRows : ["| \u2014 | _No papers_ | | | | |"]
  ].join("\n");
  const sections = [frontmatter, "", header, "", digestSection];
  if (domainSummary)
    sections.push("", domainSummary);
  sections.push("", allPapersTableSection);
  return sections.join("\n");
}
var PipelineAbortError = class extends Error {
  constructor() {
    super("Pipeline aborted by user");
    this.name = "PipelineAbortError";
  }
};
async function runDailyPipeline(app, settings, stateStore, dedupStore, snapshotStore, options = {}) {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H;
  const writer = new VaultWriter(app);
  const now = new Date();
  const date = (_a2 = options.targetDate) != null ? _a2 : getISODate(now);
  const logPath = `${settings.rootFolder}/cache/runs.log`;
  const inboxPath = `${settings.rootFolder}/inbox/${date}.md`;
  const snapshotPath = `${settings.rootFolder}/papers/${date}.json`;
  const logLines = [];
  const log = (msg) => {
    const line = `[${new Date().toISOString()}] ${msg}`;
    logLines.push(line);
    console.log(`[PaperDaily] ${msg}`);
  };
  const progress = (_b = options.onProgress) != null ? _b : () => {
  };
  const checkAbort = () => {
    var _a3;
    if ((_a3 = options.signal) == null ? void 0 : _a3.aborted)
      throw new PipelineAbortError();
  };
  let totalInputTokens = 0;
  let totalOutputTokens = 0;
  const trackUsage = (label, inputTokens, outputTokens) => {
    totalInputTokens += inputTokens;
    totalOutputTokens += outputTokens;
    log(`${label} tokens: input=${inputTokens} output=${outputTokens}`);
  };
  log(`=== Daily pipeline START date=${date} ===`);
  const interestKeywords = (_c = settings.interestKeywords) != null ? _c : [];
  log(`Settings: categories=[${settings.categories.join(",")}] interestKeywords=${interestKeywords.length} fetchMode=${(_d = settings.fetchMode) != null ? _d : "all"}`);
  let papers = [];
  let hfDailyPapers = [];
  let fetchError;
  let llmDigest = "";
  let llmError;
  const activeSources = [];
  progress(`[1/5] \u{1F4E1} \u62C9\u53D6 arXiv \u8BBA\u6587...`);
  let fetchUrl = "";
  try {
    const source = new ArxivSource();
    const windowEnd = (_e = options.windowEnd) != null ? _e : now;
    const windowStart = (_g = options.windowStart) != null ? _g : new Date(windowEnd.getTime() - ((_f = settings.timeWindowHours) != null ? _f : 72) * 3600 * 1e3);
    fetchUrl = source.buildUrl(
      { categories: settings.categories, keywords: [], maxResults: 200, sortBy: "submittedDate", windowStart, windowEnd },
      200
    );
    log(`Step 1 FETCH: url=${fetchUrl}`);
    papers = await source.fetch({
      categories: settings.categories,
      keywords: [],
      maxResults: 200,
      sortBy: "submittedDate",
      windowStart,
      windowEnd,
      targetDate: date
    });
    log(`Step 1 FETCH: got ${papers.length} papers`);
    if (papers.length > 0) {
      log(`Step 1 FETCH: first="${papers[0].title.slice(0, 80)}" published=${papers[0].published.slice(0, 10)}`);
      activeSources.push("arxiv");
    }
  } catch (err) {
    fetchError = String(err);
    log(`Step 1 FETCH ERROR: ${fetchError}`);
    await stateStore.setLastError("fetch", fetchError);
  }
  checkAbort();
  if (((_h = settings.hfSource) == null ? void 0 : _h.enabled) !== false) {
    progress(`[1/5] \u{1F917} \u62C9\u53D6 HuggingFace \u8BBA\u6587...`);
    try {
      const hfSource = new HFSource();
      const lookback = (_j = (_i = settings.hfSource) == null ? void 0 : _i.lookbackDays) != null ? _j : 3;
      let hfFetchDate = date;
      for (let d = 0; d <= lookback; d++) {
        const tryDate = d === 0 ? date : getISODate(new Date(new Date(date + "T12:00:00Z").getTime() - d * 864e5));
        const fetched = await hfSource.fetchForDate(tryDate);
        if (fetched.length > 0) {
          hfDailyPapers = fetched;
          hfFetchDate = tryDate;
          break;
        }
      }
      log(`Step 1b HF FETCH: got ${hfDailyPapers.length} papers (date=${hfFetchDate}${hfFetchDate !== date ? `, lookback from ${date}` : ""})`);
      if (hfDailyPapers.length > 0) {
        activeSources.push("huggingface");
        if (options.hfTrackStore) {
          for (const p of hfDailyPapers) {
            p.hfStreak = options.hfTrackStore.track(p.id, p.title, hfFetchDate);
          }
          await options.hfTrackStore.save();
          if ((_k = settings.hfSource) == null ? void 0 : _k.dedup) {
            const before = hfDailyPapers.length;
            hfDailyPapers = hfDailyPapers.filter((p) => !options.hfTrackStore.seenBefore(p.id, hfFetchDate));
            log(`Step 1b HF DEDUP: ${before} \u2192 ${hfDailyPapers.length} papers (removed ${before - hfDailyPapers.length} previously seen)`);
          }
        }
        const hfByBaseId = /* @__PURE__ */ new Map();
        for (const hfp of hfDailyPapers) {
          hfByBaseId.set(hfp.id, hfp);
        }
        let enrichedCount = 0;
        const arxivBaseIds = new Set(
          papers.map((p) => `arxiv:${p.id.replace(/^arxiv:/i, "").replace(/v\d+$/i, "")}`)
        );
        for (const p of papers) {
          const baseId = `arxiv:${p.id.replace(/^arxiv:/i, "").replace(/v\d+$/i, "")}`;
          const hfMatch = hfByBaseId.get(baseId);
          if (hfMatch) {
            p.hfUpvotes = (_l = hfMatch.hfUpvotes) != null ? _l : 0;
            if (hfMatch.links.hf)
              p.links = { ...p.links, hf: hfMatch.links.hf };
            enrichedCount++;
          }
        }
        log(`Step 1b HF MERGE: enriched ${enrichedCount}/${papers.length} arXiv papers with HF upvotes`);
        const hfOnlyPapers = hfDailyPapers.filter((p) => !arxivBaseIds.has(p.id));
        if (hfOnlyPapers.length > 0) {
          papers.push(...hfOnlyPapers);
          log(`Step 1b HF MERGE: added ${hfOnlyPapers.length} HF-only papers to scoring pool`);
        }
      }
    } catch (err) {
      log(`Step 1b HF FETCH ERROR: ${String(err)} (non-fatal, continuing)`);
    }
  } else {
    log(`Step 1b HF FETCH: skipped (disabled)`);
  }
  const countBeforeDedup = papers.length;
  const dedupEnabled = ((_m = settings.dedup) != null ? _m : true) && !options.skipDedup;
  if (dedupEnabled && papers.length > 0) {
    papers = papers.filter((p) => !dedupStore.hasId(p.id));
  }
  log(`Step 2 DEDUP: before=${countBeforeDedup} after=${papers.length} (filtered=${countBeforeDedup - papers.length}${dedupEnabled ? "" : ", dedup disabled"})`);
  if (((_n = settings.fetchMode) != null ? _n : "all") === "interest_only" && interestKeywords.length > 0) {
    for (const p of papers) {
      p.interestHits = computeInterestHits(p, interestKeywords);
    }
    const before = papers.length;
    papers = papers.filter((p) => {
      var _a3;
      return ((_a3 = p.interestHits) != null ? _a3 : []).length > 0;
    });
    log(`Step 2b INTEREST FILTER: ${before} \u2192 ${papers.length} papers (removed ${before - papers.length} with no keyword hits)`);
  }
  let rankedPapers = papers.length > 0 ? rankPapers(papers, interestKeywords) : [];
  log(`Step 3 RANK: ${rankedPapers.length} papers ranked`);
  checkAbort();
  if (rankedPapers.length > 0 && settings.llm.apiKey) {
    const BATCH_SIZE = 10;
    const totalBatches = Math.ceil(rankedPapers.length / BATCH_SIZE);
    const scoringTemplate = getActiveScoringPrompt(settings);
    const kwStr = interestKeywords.map((k) => `${k.keyword}(weight:${k.weight})`).join(", ");
    const normalizeId = (id) => id.replace(/^arxiv:/i, "").replace(/v\d+$/i, "").toLowerCase().trim();
    const llm = buildLLMProvider(settings);
    let totalScored = 0;
    for (let batchIdx = 0; batchIdx < totalBatches; batchIdx++) {
      const batchStart = batchIdx * BATCH_SIZE;
      const batchPapers = rankedPapers.slice(batchStart, batchStart + BATCH_SIZE);
      checkAbort();
      const paperFrom = batchStart + 1;
      const paperTo = batchStart + batchPapers.length;
      const paperTotal = rankedPapers.length;
      progress(`[2/5] \u{1F50D} \u5FEB\u901F\u9884\u7B5B (${paperFrom}\u2013${paperTo} / ${paperTotal} \u7BC7)...`);
      const papersForScoring = batchPapers.map((p) => {
        var _a3;
        return {
          id: p.id,
          title: p.title,
          abstract: p.abstract.slice(0, 250),
          interestHits: (_a3 = p.interestHits) != null ? _a3 : [],
          ...p.hfUpvotes ? { hfUpvotes: p.hfUpvotes } : {}
        };
      });
      const batchMaxTokens = Math.min(batchPapers.length * 150 + 256, 8192);
      const scoringPrompt = fillTemplate(scoringTemplate, {
        interest_keywords: kwStr,
        papers_json: JSON.stringify(papersForScoring)
      });
      try {
        const result = await llm.generate({ prompt: scoringPrompt, temperature: 0.1, maxTokens: batchMaxTokens });
        if (result.usage)
          trackUsage(`Step 3b scoring batch ${batchIdx + 1}`, result.usage.inputTokens, result.usage.outputTokens);
        const jsonMatch = result.text.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
          const scores = JSON.parse(jsonMatch[0]);
          const scoreMap = new Map(scores.map((s) => [normalizeId(s.id), s]));
          let matched = 0;
          for (const paper of batchPapers) {
            const s = scoreMap.get(normalizeId(paper.id));
            if (s) {
              paper.llmScore = s.score;
              paper.llmScoreReason = s.reason;
              if (s.summary)
                paper.llmSummary = s.summary;
              matched++;
            }
          }
          totalScored += matched;
          log(`Step 3b batch ${batchIdx + 1}/${totalBatches}: scored ${matched}/${batchPapers.length} (LLM returned ${scores.length})`);
          if (matched === 0 && scores.length > 0) {
            log(`Step 3b batch ${batchIdx + 1} WARNING: 0 matched \u2014 ID mismatch? LLM="${(_o = scores[0]) == null ? void 0 : _o.id}" vs paper="${(_p = batchPapers[0]) == null ? void 0 : _p.id}"`);
          }
        } else {
          log(`Step 3b batch ${batchIdx + 1}: could not parse JSON (response length=${result.text.length})`);
        }
      } catch (err) {
        log(`Step 3b batch ${batchIdx + 1} ERROR: ${String(err)} (non-fatal, continuing)`);
      }
    }
    rankedPapers.sort((a, b) => {
      var _a3, _b2;
      return ((_a3 = b.llmScore) != null ? _a3 : -1) - ((_b2 = a.llmScore) != null ? _b2 : -1);
    });
    log(`Step 3b LLM SCORE: done \u2014 ${totalScored}/${rankedPapers.length} papers scored across ${totalBatches} batch(es), re-ranked`);
    const catStats = /* @__PURE__ */ new Map();
    for (const paper of rankedPapers) {
      for (const cat of (_q = paper.categories) != null ? _q : []) {
        if (!catStats.has(cat))
          catStats.set(cat, { count: 0, totalScore: 0, scored: 0 });
        const s = catStats.get(cat);
        s.count++;
        if (paper.llmScore != null) {
          s.totalScore += paper.llmScore;
          s.scored++;
        }
      }
    }
    const topCats = [...catStats.entries()].sort((a, b) => b[1].count - a[1].count).slice(0, 10);
    const hotnessProgressStr = topCats.map(
      ([cat, s]) => `${cat} ${s.count}\u7BC7${s.scored > 0 ? ` avg${(s.totalScore / s.scored).toFixed(1)}` : ""}`
    ).join(" \xB7 ");
    progress(`\u{1F4CA} \u9886\u57DF\u70ED\u5EA6: ${hotnessProgressStr}`);
    log(`Step 3b DOMAIN HOTNESS: ${hotnessProgressStr}`);
  } else {
    log(`Step 3b LLM SCORE: skipped (${rankedPapers.length === 0 ? "0 papers" : "no API key"})`);
  }
  if (rankedPapers.length > 0) {
    await downloadPapersForDay(app, rankedPapers, settings, log, date);
  }
  let fulltextSection = "";
  if (((_r = settings.deepRead) == null ? void 0 : _r.enabled) && rankedPapers.length > 0 && settings.llm.apiKey) {
    const topN = Math.min((_s = settings.deepRead.topN) != null ? _s : 5, rankedPapers.length);
    const maxTokens = (_t = settings.deepRead.deepReadMaxTokens) != null ? _t : 1024;
    const drPrompt = getActiveDeepReadPrompt(settings);
    const langStr = settings.language === "zh" ? "Chinese (\u4E2D\u6587)" : "English";
    progress(`[3/5] \u{1F4D6} Deep Read \u2014 \u5171 ${topN} \u7BC7...`);
    const llm = buildLLMProvider(settings);
    const analysisResults = [];
    for (let i = 0; i < topN; i++) {
      checkAbort();
      progress(`[3/5] \u{1F4D6} Deep Read (${i + 1}/${topN})...`);
      const paper = rankedPapers[i];
      const baseId = paper.id.replace(/^arxiv:/i, "").replace(/v\d+$/i, "");
      const htmlUrl = `https://arxiv.org/html/${baseId}`;
      log(`Step 3f DEEPREAD [${i + 1}/${topN}]: ${baseId} \u2192 ${htmlUrl}`);
      const arxivUrl = `https://arxiv.org/abs/${baseId}`;
      const paperPrompt = fillTemplate(drPrompt, {
        title: paper.title,
        authors: ((_u = paper.authors) != null ? _u : []).slice(0, 5).join(", ") || "Unknown",
        published: paper.published ? paper.published.slice(0, 10) : date,
        arxiv_url: arxivUrl,
        interest_hits: ((_v = paper.interestHits) != null ? _v : []).join(", ") || "none",
        abstract: paper.abstract,
        fulltext: htmlUrl,
        language: langStr
      });
      try {
        const result = await llm.generate({ prompt: paperPrompt, temperature: 0.2, maxTokens });
        if (result.usage)
          trackUsage(`Step 3f deepread [${i + 1}]`, result.usage.inputTokens, result.usage.outputTokens);
        paper.deepReadAnalysis = result.text.trim();
        analysisResults.push(`### [${i + 1}] ${paper.title}

${paper.deepReadAnalysis}`);
        log(`Step 3f DEEPREAD [${i + 1}/${topN}]: done (${result.text.length} chars)`);
        try {
          const outputFolder = `${(_x = (_w = settings.deepRead) == null ? void 0 : _w.outputFolder) != null ? _x : "PaperDaily/deep-read"}/${date}`;
          const fileTags = [
            ...(_z = (_y = settings.deepRead) == null ? void 0 : _y.tags) != null ? _z : ["paper", "deep-read"],
            ...((_A = paper.interestHits) != null ? _A : []).map((h) => h.replace(/\s+/g, "-"))
          ];
          const fnTemplate = ((_C = (_B = settings.deepRead) == null ? void 0 : _B.fileNameTemplate) == null ? void 0 : _C.trim()) || "{{title}}-deep-read-{{model}}";
          const fileName = buildDeepReadFileName(fnTemplate, paper, baseId, date, settings.llm.model);
          const paperFrontmatter = [
            "---",
            `type: deep-read`,
            `title: "${paper.title.replace(/"/g, '\\"')}"`,
            `date: ${date}`,
            `arxivId: ${baseId}`,
            `arxivUrl: ${arxivUrl}`,
            `authors: [${((_D = paper.authors) != null ? _D : []).slice(0, 5).map((a) => `"${a.replace(/"/g, '\\"')}"`).join(", ")}]`,
            `published: ${paper.published ? paper.published.slice(0, 10) : date}`,
            `tags: [${fileTags.map((t) => `"${t}"`).join(", ")}]`,
            ...paper.llmScore != null ? [`llmScore: ${paper.llmScore}`] : [],
            "---"
          ].join("\n");
          const paperMd = `${paperFrontmatter}

# ${paper.title}

${paper.deepReadAnalysis}
`;
          await writer.writeNote(`${outputFolder}/${fileName}.md`, paperMd);
          log(`Step 3f DEEPREAD [${i + 1}/${topN}]: wrote ${outputFolder}/${fileName}.md`);
        } catch (writeErr) {
          log(`Step 3f DEEPREAD [${i + 1}/${topN}]: failed to write per-paper file: ${String(writeErr)}`);
        }
      } catch (err) {
        log(`Step 3f DEEPREAD [${i + 1}/${topN}]: LLM error: ${String(err)} \u2014 skipping`);
      }
    }
    if (analysisResults.length > 0) {
      fulltextSection = [
        "",
        `## Deep Read Analysis (top ${analysisResults.length} papers)`,
        `> Per-paper LLM analysis \u2014 model reads full paper from arxiv.org/html directly.`,
        "",
        analysisResults.join("\n\n---\n\n")
      ].join("\n");
    }
    log(`Step 3f DEEPREAD: ${analysisResults.length}/${topN} papers analysed`);
  } else {
    log(`Step 3f DEEPREAD: skipped (enabled=${(_F = (_E = settings.deepRead) == null ? void 0 : _E.enabled) != null ? _F : false})`);
  }
  checkAbort();
  if (rankedPapers.length > 0 && settings.llm.apiKey) {
    progress(`[4/5] \u{1F4DD} \u6B63\u5728\u751F\u6210\u65E5\u62A5...`);
    log(`Step 4 LLM: provider=${settings.llm.provider} model=${settings.llm.model}`);
    try {
      const llm = buildLLMProvider(settings);
      const topK = Math.min(rankedPapers.length, 20);
      const topPapersForLLM = rankedPapers.slice(0, topK).map((p) => {
        var _a3;
        return {
          id: p.id,
          title: p.title,
          abstract: p.abstract.slice(0, 500),
          categories: p.categories,
          interestHits: (_a3 = p.interestHits) != null ? _a3 : [],
          ...p.hfUpvotes ? { hfUpvotes: p.hfUpvotes } : {},
          source: p.source,
          published: p.published,
          updated: p.updated,
          links: p.links
        };
      });
      const hfForLLM = hfDailyPapers.slice(0, 15).map((p) => {
        var _a3;
        return {
          title: p.title,
          hfUpvotes: (_a3 = p.hfUpvotes) != null ? _a3 : 0,
          ...p.hfStreak && p.hfStreak > 1 ? { streakDays: p.hfStreak } : {}
        };
      });
      const hfEnabled = ((_G = settings.hfSource) == null ? void 0 : _G.enabled) !== false && hfDailyPapers.length > 0;
      const hfDataSection = hfEnabled ? `Note: papers with "source": "hf" are HuggingFace-only picks. Treat them identically to arXiv papers.

## HuggingFace Daily Papers (full list for reference, sorted by upvotes):
${JSON.stringify(hfForLLM, null, 2)}` : "";
      const hfSignalSection = hfEnabled ? `### HF \u793E\u533A\u4FE1\u53F7 / HF Community Signal
From the HuggingFace full list, note any papers NOT already covered above. One line each: title + why the community is upvoting it + your take on whether it lives up to the hype.` : "";
      const prompt2 = fillTemplate(getActivePrompt(settings), {
        date,
        papers_json: JSON.stringify(topPapersForLLM, null, 2),
        hf_papers_json: JSON.stringify(hfForLLM, null, 2),
        hf_data_section: hfDataSection,
        hf_signal_section: hfSignalSection,
        fulltext_section: fulltextSection,
        local_pdfs: "",
        interest_keywords: interestKeywords.map((k) => `${k.keyword}(weight:${k.weight})`).join(", "),
        language: settings.language === "zh" ? "Chinese (\u4E2D\u6587)" : "English"
      });
      const result = await llm.generate({ prompt: prompt2, temperature: settings.llm.temperature, maxTokens: settings.llm.maxTokens });
      llmDigest = result.text;
      if (result.usage)
        trackUsage("Step 4 digest", result.usage.inputTokens, result.usage.outputTokens);
      log(`Step 4 LLM: success, response length=${llmDigest.length} chars`);
    } catch (err) {
      llmError = String(err);
      log(`Step 4 LLM ERROR: ${llmError}`);
      await stateStore.setLastError("llm", llmError);
    }
  } else if (!settings.llm.apiKey) {
    llmError = "LLM API key not configured";
    log(`Step 4 LLM: skipped (no API key)`);
  } else {
    log(`Step 4 LLM: skipped (0 papers)`);
  }
  const errorMsg = fetchError ? `Fetch failed: ${fetchError}${llmError ? `

LLM failed: ${llmError}` : ""}` : llmError ? `LLM failed: ${llmError}` : void 0;
  progress(`[5/5] \u{1F4BE} \u5199\u5165\u6587\u4EF6...`);
  try {
    const catStats2 = /* @__PURE__ */ new Map();
    for (const paper of rankedPapers) {
      for (const cat of (_H = paper.categories) != null ? _H : []) {
        if (!catStats2.has(cat))
          catStats2.set(cat, { count: 0, totalScore: 0, scored: 0 });
        const s = catStats2.get(cat);
        s.count++;
        if (paper.llmScore != null) {
          s.totalScore += paper.llmScore;
          s.scored++;
        }
      }
    }
    const topCats2 = [...catStats2.entries()].sort((a, b) => b[1].count - a[1].count).slice(0, 10);
    const domainSummary = topCats2.length > 0 ? [
      "## \u9886\u57DF\u70ED\u5EA6 / Domain Hotness",
      "",
      "| \u9886\u57DF | \u8BBA\u6587\u6570 | \u5E73\u5747\u5206 |",
      "|------|--------|--------|",
      ...topCats2.map(
        ([cat, s]) => `| ${cat} | ${s.count} | ${s.scored > 0 ? (s.totalScore / s.scored).toFixed(1) : "-"} |`
      )
    ].join("\n") : "";
    const markdown = buildDailyMarkdown(date, settings, rankedPapers, llmDigest, activeSources, domainSummary, errorMsg);
    await writer.writeNote(inboxPath, markdown);
    log(`Step 5 WRITE: markdown written to ${inboxPath}`);
  } catch (err) {
    log(`Step 5 WRITE ERROR: ${String(err)}`);
    await stateStore.setLastError("write", String(err));
    throw err;
  }
  await snapshotStore.writeSnapshot(date, rankedPapers, fetchError);
  log(`Step 6 SNAPSHOT: written to ${snapshotPath} (${rankedPapers.length} papers)`);
  if (dedupEnabled && rankedPapers.length > 0) {
    await dedupStore.markSeenBatch(rankedPapers.map((p) => p.id), date);
    log(`Step 7 DEDUP: marked ${rankedPapers.length} IDs as seen`);
  }
  if (!options.targetDate) {
    await stateStore.setLastDailyRun(now.toISOString());
  }
  log(`=== Daily pipeline END date=${date} papers=${rankedPapers.length} ===`);
  const tokenSummary = totalInputTokens > 0 ? ` | tokens: ${totalInputTokens.toLocaleString()}\u2192${totalOutputTokens.toLocaleString()}` : "";
  progress(`\u2705 \u5B8C\u6210\uFF01${rankedPapers.length} \u7BC7\u8BBA\u6587${tokenSummary}`);
  await writer.appendToNote(logPath, logLines.join("\n") + "\n");
}

// src/pipeline/backfillPipeline.ts
function parseDateYMD(str) {
  const [y, m, d] = str.split("-").map(Number);
  return new Date(y, m - 1, d);
}
function addDays(d, n) {
  const copy = new Date(d);
  copy.setDate(copy.getDate() + n);
  return copy;
}
function toDateStr(d) {
  return d.toISOString().slice(0, 10);
}
async function runBackfillPipeline(app, settings, stateStore, dedupStore, snapshotStore, options) {
  var _a2;
  const start = parseDateYMD(options.startDate);
  const end = parseDateYMD(options.endDate);
  const diffMs = end.getTime() - start.getTime();
  const diffDays = Math.floor(diffMs / (1e3 * 60 * 60 * 24)) + 1;
  if (diffDays < 1) {
    throw new Error(`Invalid date range: startDate must be <= endDate`);
  }
  if (diffDays > settings.backfillMaxDays) {
    throw new Error(`Backfill range (${diffDays} days) exceeds backfillMaxDays (${settings.backfillMaxDays})`);
  }
  const dates = [];
  let current = new Date(start);
  while (current <= end) {
    dates.push(toDateStr(current));
    current = addDays(current, 1);
  }
  const processed = [];
  const errors = {};
  for (let i = 0; i < dates.length; i++) {
    if ((_a2 = options.signal) == null ? void 0 : _a2.aborted)
      throw new PipelineAbortError();
    const date = dates[i];
    if (options.onProgress) {
      options.onProgress(date, i + 1, dates.length);
    }
    try {
      const dayStart = new Date(`${date}T00:00:00Z`);
      const dayEnd = new Date(`${date}T23:59:59Z`);
      await runDailyPipeline(app, settings, stateStore, dedupStore, snapshotStore, {
        targetDate: date,
        windowStart: dayStart,
        windowEnd: dayEnd,
        skipDedup: false,
        signal: options.signal
      });
      processed.push(date);
    } catch (err) {
      errors[date] = String(err);
    }
  }
  return { processed, errors };
}

// src/scheduler/scheduler.ts
function parseTime(hhmm) {
  const [h, m] = hhmm.split(":").map(Number);
  return { hour: h != null ? h : 8, minute: m != null ? m : 0 };
}
function isSameDay(a, b) {
  return a.getFullYear() === b.getFullYear() && a.getMonth() === b.getMonth() && a.getDate() === b.getDate();
}
var Scheduler = class {
  constructor(getSettings, stateStore, callbacks) {
    this.getSettings = getSettings;
    this.stateStore = stateStore;
    this.callbacks = callbacks;
    this.intervalId = null;
    this.running = false;
  }
  start() {
    if (this.intervalId !== null)
      return;
    this.intervalId = window.setInterval(() => this.tick(), 60 * 1e3);
  }
  stop() {
    if (this.intervalId !== null) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  async tick() {
    if (this.running)
      return;
    this.running = true;
    try {
      await this.checkAndRun();
    } finally {
      this.running = false;
    }
  }
  async checkAndRun() {
    const now = new Date();
    const settings = this.getSettings();
    const state = this.stateStore.get();
    const dailyTime = parseTime(settings.schedule.dailyTime);
    const scheduledToday = new Date(now);
    scheduledToday.setHours(dailyTime.hour, dailyTime.minute, 0, 0);
    if (now >= scheduledToday) {
      const lastRun = state.lastDailyRun ? new Date(state.lastDailyRun) : null;
      const alreadyRanToday = lastRun && isSameDay(now, lastRun);
      const today = now.toISOString().slice(0, 10);
      if (!alreadyRanToday || !await this.callbacks.todayFileExists(today)) {
        await this.callbacks.onDaily();
      }
    }
  }
};

// src/ui/floatingProgress.ts
var FloatingProgress = class {
  constructor(onStop, title = "\u{1F4DA} Paper Daily \u8FD0\u884C\u4E2D") {
    this.el = document.body.createDiv();
    this.el.style.cssText = [
      "position:fixed",
      "bottom:24px",
      "right:24px",
      "z-index:9999",
      "background:var(--background-secondary)",
      "border:1px solid var(--background-modifier-border)",
      "border-radius:10px",
      "padding:14px 18px 12px",
      "min-width:300px",
      "max-width:420px",
      "box-shadow:0 4px 20px rgba(0,0,0,0.25)",
      "font-family:var(--font-interface)"
    ].join(";");
    const header = this.el.createDiv();
    header.style.cssText = "display:flex;justify-content:space-between;align-items:center;margin-bottom:10px;";
    const titleEl = header.createEl("span", { text: title });
    titleEl.style.cssText = "font-weight:600;font-size:0.92em;color:var(--text-normal);";
    const stopBtn = header.createEl("button", { text: "\u505C\u6B62" });
    stopBtn.style.cssText = [
      "padding:2px 10px",
      "border-radius:4px",
      "cursor:pointer",
      "font-size:0.8em",
      "border:1px solid var(--text-error,#cc4444)",
      "color:var(--text-error,#cc4444)",
      "background:transparent"
    ].join(";");
    stopBtn.onclick = () => {
      onStop();
      stopBtn.disabled = true;
      stopBtn.textContent = "\u505C\u6B62\u4E2D...";
    };
    this.msgEl = this.el.createEl("div");
    this.msgEl.style.cssText = "font-size:0.83em;color:var(--text-muted);word-break:break-word;line-height:1.4;";
    this.msgEl.setText("\u521D\u59CB\u5316\u4E2D...");
  }
  setMessage(msg) {
    this.msgEl.setText(msg);
  }
  destroy() {
    this.el.remove();
  }
};

// src/main.ts
var PaperDailyPlugin = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.activeAbortController = null;
    this.activeBackfillController = null;
  }
  async onload() {
    await this.loadSettings();
    await this.initStorage();
    this.initScheduler();
    this.registerCommands();
    this.addSettingTab(new PaperDailySettingTab(this.app, this));
    this.app.workspace.onLayoutReady(() => {
      void this.runTodayIfMissing();
    });
    console.log("Paper Daily loaded.");
  }
  onunload() {
    this.scheduler.stop();
    console.log("Paper Daily unloaded.");
  }
  async loadSettings() {
    var _a2, _b;
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.settings.llm = Object.assign({}, DEFAULT_SETTINGS.llm, this.settings.llm);
    this.settings.schedule = Object.assign({}, DEFAULT_SETTINGS.schedule, this.settings.schedule);
    this.settings.hfSource = Object.assign({}, DEFAULT_SETTINGS.hfSource, this.settings.hfSource);
    this.settings.rssSource = Object.assign({}, DEFAULT_SETTINGS.rssSource, this.settings.rssSource);
    this.settings.paperDownload = Object.assign({}, DEFAULT_SETTINGS.paperDownload, this.settings.paperDownload);
    if (Array.isArray(this.settings.interestKeywords) && this.settings.interestKeywords.length > 0 && typeof this.settings.interestKeywords[0] === "string") {
      this.settings.interestKeywords = this.settings.interestKeywords.map((kw) => ({ keyword: kw, weight: 1 }));
    }
    const locale = (_b = (_a2 = window.moment) == null ? void 0 : _a2.locale()) != null ? _b : "";
    this.settings.language = locale.startsWith("zh") ? "zh" : "en";
    await this.loadSettingsFromVaultFile();
  }
  async saveSettings() {
    await this.saveData(this.settings);
    void this.saveSettingsToVaultFile();
  }
  get configFilePath() {
    return `${this.settings.rootFolder}/config.json`;
  }
  async loadSettingsFromVaultFile() {
    try {
      const file = this.app.vault.getAbstractFileByPath((0, import_obsidian7.normalizePath)(this.configFilePath));
      if (!(file instanceof import_obsidian7.TFile))
        return;
      const content = await this.app.vault.read(file);
      const vaultSettings = JSON.parse(content);
      this.settings = Object.assign({}, this.settings, vaultSettings);
      this.settings.llm = Object.assign({}, DEFAULT_SETTINGS.llm, this.settings.llm);
      this.settings.hfSource = Object.assign({}, DEFAULT_SETTINGS.hfSource, this.settings.hfSource);
      this.settings.rssSource = Object.assign({}, DEFAULT_SETTINGS.rssSource, this.settings.rssSource);
      this.settings.paperDownload = Object.assign({}, DEFAULT_SETTINGS.paperDownload, this.settings.paperDownload);
      console.log(`[PaperDaily] Loaded settings from vault: ${this.configFilePath}`);
    } catch (e) {
    }
  }
  async saveSettingsToVaultFile() {
    try {
      const writer = new VaultWriter(this.app);
      await writer.writeNote(this.configFilePath, JSON.stringify(this.settings, null, 2));
    } catch (e) {
      console.error("[PaperDaily] Failed to write vault config file:", e);
    }
  }
  async initStorage() {
    const writer = new VaultWriter(this.app);
    this.stateStore = new StateStore(writer, this.settings.rootFolder);
    this.dedupStore = new DedupStore(writer, this.settings.rootFolder);
    this.snapshotStore = new SnapshotStore(writer, this.settings.rootFolder);
    this.hfTrackStore = new HFTrackStore(writer, this.settings.rootFolder);
    await this.stateStore.load();
    await this.dedupStore.load();
    await this.hfTrackStore.load();
    const root = this.settings.rootFolder;
    for (const sub of ["inbox", "papers", "cache"]) {
      await writer.ensureFolder(`${root}/${sub}`);
    }
  }
  initScheduler() {
    this.scheduler = new Scheduler(
      () => this.settings,
      this.stateStore,
      {
        onDaily: () => {
          if (this.activeAbortController)
            return Promise.resolve();
          return this.runDailyWithUI();
        },
        todayFileExists: (date) => this.todayFileExists(date)
      }
    );
    this.scheduler.start();
  }
  registerCommands() {
    this.addCommand({
      id: "run-daily-now",
      name: "Run daily fetch & summarize now",
      callback: () => {
        void this.runDailyWithUI();
      }
    });
    this.addCommand({
      id: "backfill",
      name: "Backfill daily summaries for date range",
      callback: () => {
        new BackfillModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "rebuild-index",
      name: "Rebuild index from local cache",
      callback: async () => {
        new import_obsidian7.Notice("Paper Daily: Rebuilding dedup index...");
        try {
          await this.dedupStore.load();
          new import_obsidian7.Notice("Paper Daily: Index rebuilt.");
        } catch (err) {
          new import_obsidian7.Notice(`Paper Daily Error: ${String(err)}`);
        }
      }
    });
    this.addCommand({
      id: "open-settings",
      name: "Open settings",
      callback: () => {
        var _a2;
        (_a2 = this.app.setting) == null ? void 0 : _a2.openTabById("paper-daily");
      }
    });
  }
  async runDaily(onProgress, signal) {
    await runDailyPipeline(
      this.app,
      this.settings,
      this.stateStore,
      this.dedupStore,
      this.snapshotStore,
      { hfTrackStore: this.hfTrackStore, onProgress, signal }
    );
  }
  /** Run daily pipeline with floating UI and stop button. */
  async runDailyWithUI() {
    if (this.activeAbortController) {
      new import_obsidian7.Notice("Paper Daily: \u4EFB\u52A1\u5DF2\u5728\u8FD0\u884C\u4E2D\u3002");
      return;
    }
    const controller = new AbortController();
    this.activeAbortController = controller;
    const fp = new FloatingProgress(() => {
      controller.abort();
    });
    try {
      await this.runDaily((msg) => fp.setMessage(msg), controller.signal);
      fp.setMessage("\u2705 \u5B8C\u6210\uFF01");
      setTimeout(() => fp.destroy(), 3e3);
    } catch (err) {
      if (err instanceof PipelineAbortError) {
        fp.setMessage("\u23F9 \u5DF2\u505C\u6B62\u3002");
        setTimeout(() => fp.destroy(), 2e3);
      } else {
        fp.setMessage(`\u274C \u9519\u8BEF: ${String(err)}`);
        setTimeout(() => fp.destroy(), 6e3);
      }
    } finally {
      this.activeAbortController = null;
    }
  }
  todayFileExists(date) {
    const writer = new VaultWriter(this.app);
    return writer.fileExists(`${this.settings.rootFolder}/inbox/${date}.md`);
  }
  /** Called once on startup: silently generate today's file if it is missing. */
  async runTodayIfMissing() {
    const today = new Date().toISOString().slice(0, 10);
    if (await this.todayFileExists(today))
      return;
    void this.runDailyWithUI();
  }
  async clearDedup() {
    await this.dedupStore.clear();
  }
  async runBackfill(startDate, endDate, onProgress, signal) {
    const result = await runBackfillPipeline(
      this.app,
      this.settings,
      this.stateStore,
      this.dedupStore,
      this.snapshotStore,
      {
        startDate,
        endDate,
        signal,
        onProgress: (date, index, total) => {
          onProgress(`Processing ${date} (${index}/${total})...`);
        }
      }
    );
    const errCount = Object.keys(result.errors).length;
    if (errCount > 0) {
      onProgress(`Done. ${result.processed.length} succeeded, ${errCount} failed: ${Object.keys(result.errors).join(", ")}`);
    } else {
      onProgress(`Done. ${result.processed.length} days processed.`);
    }
  }
  /** Run backfill pipeline with floating UI and stop button. */
  async runBackfillWithUI(startDate, endDate) {
    if (this.activeBackfillController) {
      new import_obsidian7.Notice("Paper Daily: \u6279\u91CF\u751F\u6210\u5DF2\u5728\u8FD0\u884C\u4E2D\u3002");
      return;
    }
    const controller = new AbortController();
    this.activeBackfillController = controller;
    const fp = new FloatingProgress(() => {
      controller.abort();
    }, "\u{1F4C5} \u6279\u91CF\u751F\u6210\u65E5\u62A5");
    try {
      await this.runBackfill(startDate, endDate, (msg) => fp.setMessage(msg), controller.signal);
      fp.setMessage("\u2705 \u5B8C\u6210\uFF01");
      setTimeout(() => fp.destroy(), 3e3);
    } catch (err) {
      if (err instanceof PipelineAbortError) {
        fp.setMessage("\u23F9 \u5DF2\u505C\u6B62\u3002");
        setTimeout(() => fp.destroy(), 2e3);
      } else {
        fp.setMessage(`\u274C \u9519\u8BEF: ${String(err)}`);
        setTimeout(() => fp.destroy(), 6e3);
      }
    } finally {
      this.activeBackfillController = null;
    }
  }
  async testFetch() {
    var _a2, _b;
    const source = new ArxivSource();
    const now = new Date();
    const params = {
      categories: this.settings.categories,
      keywords: [],
      maxResults: 200,
      sortBy: "submittedDate",
      windowStart: new Date(now.getTime() - 72 * 3600 * 1e3),
      windowEnd: now
    };
    const url = source.buildUrl(params, 200);
    try {
      const papers = await source.fetch(params);
      return {
        url,
        total: papers.length,
        firstTitle: (_b = (_a2 = papers[0]) == null ? void 0 : _a2.title) != null ? _b : "(none)"
      };
    } catch (err) {
      return { url, total: 0, firstTitle: "", error: String(err) };
    }
  }
};
var BackfillModal = class extends import_obsidian7.Modal {
  constructor(app, plugin) {
    super(app);
    this.startDate = "";
    this.endDate = "";
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Backfill Daily Summaries" });
    new import_obsidian7.Setting(contentEl).setName("Start Date").setDesc("YYYY-MM-DD").addText((text) => text.setPlaceholder("2026-02-01").onChange((v) => {
      this.startDate = v;
    }));
    new import_obsidian7.Setting(contentEl).setName("End Date").setDesc("YYYY-MM-DD").addText((text) => text.setPlaceholder("2026-02-28").onChange((v) => {
      this.endDate = v;
    }));
    this.statusEl = contentEl.createEl("p", { text: "", cls: "paper-daily-backfill-status" });
    new import_obsidian7.Setting(contentEl).addButton((btn) => btn.setButtonText("Run Backfill").setCta().onClick(async () => {
      if (!this.startDate || !this.endDate) {
        this.statusEl.setText("Please enter both start and end dates.");
        return;
      }
      this.statusEl.setText("Starting backfill...");
      try {
        await this.plugin.runBackfill(
          this.startDate,
          this.endDate,
          (msg) => {
            this.statusEl.setText(msg);
          }
        );
      } catch (err) {
        this.statusEl.setText(`Error: ${String(err)}`);
      }
    })).addButton((btn) => btn.setButtonText("Close").onClick(() => this.close()));
  }
  onClose() {
    this.contentEl.empty();
  }
};
